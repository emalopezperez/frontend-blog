import {
  require_react_dom
} from "./chunk-JZ3YVIXN.js";
import {
  require_react
} from "./chunk-6CE3F7YD.js";
import {
  __commonJS
} from "./chunk-TFWDKVI3.js";

// ../../../../../../node_modules/@swc/helpers/lib/_interop_require_default.js
var require_interop_require_default = __commonJS({
  "../../../../../../node_modules/@swc/helpers/lib/_interop_require_default.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _interopRequireDefault;
      }
    });
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  }
});

// ../../../../../../node_modules/@swc/helpers/lib/_async_to_generator.js
var require_async_to_generator = __commonJS({
  "../../../../../../node_modules/@swc/helpers/lib/_async_to_generator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _asyncToGenerator;
      }
    });
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
  }
});

// ../../../../../../node_modules/@swc/helpers/lib/_extends.js
var require_extends = __commonJS({
  "../../../../../../node_modules/@swc/helpers/lib/_extends.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _extends;
      }
    });
    function extends_() {
      extends_ = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return extends_.apply(this, arguments);
    }
    function _extends() {
      return extends_.apply(this, arguments);
    }
  }
});

// ../../../../../../node_modules/@swc/helpers/lib/_interop_require_wildcard.js
var require_interop_require_wildcard = __commonJS({
  "../../../../../../node_modules/@swc/helpers/lib/_interop_require_wildcard.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _interopRequireWildcard;
      }
    });
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
  }
});

// ../../../../../../node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js
var require_remove_trailing_slash = __commonJS({
  "../../../../../../node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.removeTrailingSlash = removeTrailingSlash;
    function removeTrailingSlash(route) {
      return route.replace(/\/$/, "") || "/";
    }
  }
});

// ../../../../../../node_modules/next/dist/shared/lib/router/utils/get-asset-path-from-route.js
var require_get_asset_path_from_route = __commonJS({
  "../../../../../../node_modules/next/dist/shared/lib/router/utils/get-asset-path-from-route.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = getAssetPathFromRoute;
    function getAssetPathFromRoute(route, ext = "") {
      const path = route === "/" ? "/index" : /^\/index(\/|$)/.test(route) ? `/index${route}` : `${route}`;
      return path + ext;
    }
  }
});

// ../../../../../../node_modules/next/dist/client/trusted-types.js
var require_trusted_types = __commonJS({
  "../../../../../../node_modules/next/dist/client/trusted-types.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.__unsafeCreateTrustedScriptURL = __unsafeCreateTrustedScriptURL;
    var policy;
    function getPolicy() {
      if (typeof policy === "undefined" && typeof window !== "undefined") {
        var ref;
        policy = ((ref = window.trustedTypes) == null ? void 0 : ref.createPolicy("nextjs", {
          createHTML: (input) => input,
          createScript: (input) => input,
          createScriptURL: (input) => input
        })) || null;
      }
      return policy;
    }
    function __unsafeCreateTrustedScriptURL(url) {
      var ref;
      return ((ref = getPolicy()) == null ? void 0 : ref.createScriptURL(url)) || url;
    }
    if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
      Object.defineProperty(exports.default, "__esModule", { value: true });
      Object.assign(exports.default, exports);
      module.exports = exports.default;
    }
  }
});

// ../../../../../../node_modules/next/dist/client/request-idle-callback.js
var require_request_idle_callback = __commonJS({
  "../../../../../../node_modules/next/dist/client/request-idle-callback.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.cancelIdleCallback = exports.requestIdleCallback = void 0;
    var requestIdleCallback = typeof self !== "undefined" && self.requestIdleCallback && self.requestIdleCallback.bind(window) || function(cb) {
      let start = Date.now();
      return self.setTimeout(function() {
        cb({
          didTimeout: false,
          timeRemaining: function() {
            return Math.max(0, 50 - (Date.now() - start));
          }
        });
      }, 1);
    };
    exports.requestIdleCallback = requestIdleCallback;
    var cancelIdleCallback = typeof self !== "undefined" && self.cancelIdleCallback && self.cancelIdleCallback.bind(window) || function(id) {
      return clearTimeout(id);
    };
    exports.cancelIdleCallback = cancelIdleCallback;
    if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
      Object.defineProperty(exports.default, "__esModule", { value: true });
      Object.assign(exports.default, exports);
      module.exports = exports.default;
    }
  }
});

// ../../../../../../node_modules/next/dist/client/route-loader.js
var require_route_loader = __commonJS({
  "../../../../../../node_modules/next/dist/client/route-loader.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.markAssetError = markAssetError;
    exports.isAssetError = isAssetError;
    exports.getClientBuildManifest = getClientBuildManifest;
    exports.createRouteLoader = createRouteLoader;
    var _interop_require_default = require_interop_require_default().default;
    var _getAssetPathFromRoute = _interop_require_default(require_get_asset_path_from_route());
    var _trustedTypes = require_trusted_types();
    var _requestIdleCallback = require_request_idle_callback();
    var MS_MAX_IDLE_DELAY = 3800;
    function withFuture(key, map, generator) {
      let entry = map.get(key);
      if (entry) {
        if ("future" in entry) {
          return entry.future;
        }
        return Promise.resolve(entry);
      }
      let resolver;
      const prom = new Promise((resolve) => {
        resolver = resolve;
      });
      map.set(key, entry = {
        resolve: resolver,
        future: prom
      });
      return generator ? generator().then((value) => (resolver(value), value)).catch((err) => {
        map.delete(key);
        throw err;
      }) : prom;
    }
    var ASSET_LOAD_ERROR = Symbol("ASSET_LOAD_ERROR");
    function markAssetError(err) {
      return Object.defineProperty(err, ASSET_LOAD_ERROR, {});
    }
    function isAssetError(err) {
      return err && ASSET_LOAD_ERROR in err;
    }
    function hasPrefetch(link) {
      try {
        link = document.createElement("link");
        return (
          // detect IE11 since it supports prefetch but isn't detected
          // with relList.support
          !!window.MSInputMethodContext && !!document.documentMode || link.relList.supports("prefetch")
        );
      } catch (e) {
        return false;
      }
    }
    var canPrefetch = hasPrefetch();
    function prefetchViaDom(href, as, link) {
      return new Promise((resolve, reject) => {
        const selector = `
      link[rel="prefetch"][href^="${href}"],
      link[rel="preload"][href^="${href}"],
      script[src^="${href}"]`;
        if (document.querySelector(selector)) {
          return resolve();
        }
        link = document.createElement("link");
        if (as)
          link.as = as;
        link.rel = `prefetch`;
        link.crossOrigin = process.env.__NEXT_CROSS_ORIGIN;
        link.onload = resolve;
        link.onerror = () => reject(markAssetError(new Error(`Failed to prefetch: ${href}`)));
        link.href = href;
        document.head.appendChild(link);
      });
    }
    function appendScript(src, script) {
      return new Promise((resolve, reject) => {
        script = document.createElement("script");
        script.onload = resolve;
        script.onerror = () => reject(markAssetError(new Error(`Failed to load script: ${src}`)));
        script.crossOrigin = process.env.__NEXT_CROSS_ORIGIN;
        script.src = src;
        document.body.appendChild(script);
      });
    }
    var devBuildPromise;
    function resolvePromiseWithTimeout(p, ms, err) {
      return new Promise((resolve, reject) => {
        let cancelled = false;
        p.then((r) => {
          cancelled = true;
          resolve(r);
        }).catch(reject);
        if (true) {
          (devBuildPromise || Promise.resolve()).then(() => {
            (0, _requestIdleCallback).requestIdleCallback(() => setTimeout(() => {
              if (!cancelled) {
                reject(err);
              }
            }, ms));
          });
        }
        if (false) {
          (0, _requestIdleCallback).requestIdleCallback(() => setTimeout(() => {
            if (!cancelled) {
              reject(err);
            }
          }, ms));
        }
      });
    }
    function getClientBuildManifest() {
      if (self.__BUILD_MANIFEST) {
        return Promise.resolve(self.__BUILD_MANIFEST);
      }
      const onBuildManifest = new Promise((resolve) => {
        const cb = self.__BUILD_MANIFEST_CB;
        self.__BUILD_MANIFEST_CB = () => {
          resolve(self.__BUILD_MANIFEST);
          cb && cb();
        };
      });
      return resolvePromiseWithTimeout(onBuildManifest, MS_MAX_IDLE_DELAY, markAssetError(new Error("Failed to load client build manifest")));
    }
    function getFilesForRoute(assetPrefix, route) {
      if (true) {
        const scriptUrl = assetPrefix + "/_next/static/chunks/pages" + encodeURI((0, _getAssetPathFromRoute).default(route, ".js"));
        return Promise.resolve({
          scripts: [
            (0, _trustedTypes).__unsafeCreateTrustedScriptURL(scriptUrl)
          ],
          // Styles are handled by `style-loader` in development:
          css: []
        });
      }
      return getClientBuildManifest().then((manifest) => {
        if (!(route in manifest)) {
          throw markAssetError(new Error(`Failed to lookup route: ${route}`));
        }
        const allFiles = manifest[route].map((entry) => assetPrefix + "/_next/" + encodeURI(entry));
        return {
          scripts: allFiles.filter((v) => v.endsWith(".js")).map((v) => (0, _trustedTypes).__unsafeCreateTrustedScriptURL(v)),
          css: allFiles.filter((v) => v.endsWith(".css"))
        };
      });
    }
    function createRouteLoader(assetPrefix) {
      const entrypoints = /* @__PURE__ */ new Map();
      const loadedScripts = /* @__PURE__ */ new Map();
      const styleSheets = /* @__PURE__ */ new Map();
      const routes = /* @__PURE__ */ new Map();
      function maybeExecuteScript(src) {
        if (false) {
          let prom = loadedScripts.get(src.toString());
          if (prom) {
            return prom;
          }
          if (document.querySelector(`script[src^="${src}"]`)) {
            return Promise.resolve();
          }
          loadedScripts.set(src.toString(), prom = appendScript(src));
          return prom;
        } else {
          return appendScript(src);
        }
      }
      function fetchStyleSheet(href) {
        let prom = styleSheets.get(href);
        if (prom) {
          return prom;
        }
        styleSheets.set(href, prom = fetch(href).then((res) => {
          if (!res.ok) {
            throw new Error(`Failed to load stylesheet: ${href}`);
          }
          return res.text().then((text) => ({
            href,
            content: text
          }));
        }).catch((err) => {
          throw markAssetError(err);
        }));
        return prom;
      }
      return {
        whenEntrypoint(route) {
          return withFuture(route, entrypoints);
        },
        onEntrypoint(route, execute) {
          (execute ? Promise.resolve().then(() => execute()).then((exports2) => ({
            component: exports2 && exports2.default || exports2,
            exports: exports2
          }), (err) => ({
            error: err
          })) : Promise.resolve(void 0)).then((input) => {
            const old = entrypoints.get(route);
            if (old && "resolve" in old) {
              if (input) {
                entrypoints.set(route, input);
                old.resolve(input);
              }
            } else {
              if (input) {
                entrypoints.set(route, input);
              } else {
                entrypoints.delete(route);
              }
              routes.delete(route);
            }
          });
        },
        loadRoute(route, prefetch) {
          return withFuture(route, routes, () => {
            let devBuildPromiseResolve;
            if (true) {
              devBuildPromise = new Promise((resolve) => {
                devBuildPromiseResolve = resolve;
              });
            }
            return resolvePromiseWithTimeout(getFilesForRoute(assetPrefix, route).then(({ scripts, css }) => {
              return Promise.all([
                entrypoints.has(route) ? [] : Promise.all(scripts.map(maybeExecuteScript)),
                Promise.all(css.map(fetchStyleSheet))
              ]);
            }).then((res) => {
              return this.whenEntrypoint(route).then((entrypoint) => ({
                entrypoint,
                styles: res[1]
              }));
            }), MS_MAX_IDLE_DELAY, markAssetError(new Error(`Route did not complete loading: ${route}`))).then(({ entrypoint, styles }) => {
              const res = Object.assign({
                styles
              }, entrypoint);
              return "error" in entrypoint ? entrypoint : res;
            }).catch((err) => {
              if (prefetch) {
                throw err;
              }
              return {
                error: err
              };
            }).finally(() => {
              return devBuildPromiseResolve == null ? void 0 : devBuildPromiseResolve();
            });
          });
        },
        prefetch(route) {
          let cn;
          if (cn = navigator.connection) {
            if (cn.saveData || /2g/.test(cn.effectiveType))
              return Promise.resolve();
          }
          return getFilesForRoute(assetPrefix, route).then((output) => Promise.all(canPrefetch ? output.scripts.map((script) => prefetchViaDom(script.toString(), "script")) : [])).then(() => {
            (0, _requestIdleCallback).requestIdleCallback(() => this.loadRoute(route, true).catch(() => {
            }));
          }).catch(
            // swallow prefetch errors
            () => {
            }
          );
        }
      };
    }
    if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
      Object.defineProperty(exports.default, "__esModule", { value: true });
      Object.assign(exports.default, exports);
      module.exports = exports.default;
    }
  }
});

// ../../../../../../node_modules/@swc/helpers/lib/_object_without_properties_loose.js
var require_object_without_properties_loose = __commonJS({
  "../../../../../../node_modules/@swc/helpers/lib/_object_without_properties_loose.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _objectWithoutPropertiesLoose;
      }
    });
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
  }
});

// ../../../../../../node_modules/next/dist/shared/lib/head-manager-context.js
var require_head_manager_context = __commonJS({
  "../../../../../../node_modules/next/dist/shared/lib/head-manager-context.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.HeadManagerContext = void 0;
    var _interop_require_default = require_interop_require_default().default;
    var _react = _interop_require_default(require_react());
    var HeadManagerContext = _react.default.createContext({});
    exports.HeadManagerContext = HeadManagerContext;
    if (true) {
      HeadManagerContext.displayName = "HeadManagerContext";
    }
  }
});

// ../../../../../../node_modules/next/dist/client/head-manager.js
var require_head_manager = __commonJS({
  "../../../../../../node_modules/next/dist/client/head-manager.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = initHeadManager;
    exports.isEqualNode = isEqualNode;
    exports.DOMAttributeNames = void 0;
    function initHeadManager() {
      return {
        mountedInstances: /* @__PURE__ */ new Set(),
        updateHead: (head) => {
          const tags = {};
          head.forEach((h) => {
            if (
              // If the font tag is loaded only on client navigation
              // it won't be inlined. In this case revert to the original behavior
              h.type === "link" && h.props["data-optimized-fonts"]
            ) {
              if (document.querySelector(`style[data-href="${h.props["data-href"]}"]`)) {
                return;
              } else {
                h.props.href = h.props["data-href"];
                h.props["data-href"] = void 0;
              }
            }
            const components = tags[h.type] || [];
            components.push(h);
            tags[h.type] = components;
          });
          const titleComponent = tags.title ? tags.title[0] : null;
          let title = "";
          if (titleComponent) {
            const { children } = titleComponent.props;
            title = typeof children === "string" ? children : Array.isArray(children) ? children.join("") : "";
          }
          if (title !== document.title)
            document.title = title;
          [
            "meta",
            "base",
            "link",
            "style",
            "script"
          ].forEach((type) => {
            updateElements(type, tags[type] || []);
          });
        }
      };
    }
    var DOMAttributeNames = {
      acceptCharset: "accept-charset",
      className: "class",
      htmlFor: "for",
      httpEquiv: "http-equiv",
      noModule: "noModule"
    };
    exports.DOMAttributeNames = DOMAttributeNames;
    function reactElementToDOM({ type, props }) {
      const el = document.createElement(type);
      for (const p in props) {
        if (!props.hasOwnProperty(p))
          continue;
        if (p === "children" || p === "dangerouslySetInnerHTML")
          continue;
        if (props[p] === void 0)
          continue;
        const attr = DOMAttributeNames[p] || p.toLowerCase();
        if (type === "script" && (attr === "async" || attr === "defer" || attr === "noModule")) {
          el[attr] = !!props[p];
        } else {
          el.setAttribute(attr, props[p]);
        }
      }
      const { children, dangerouslySetInnerHTML } = props;
      if (dangerouslySetInnerHTML) {
        el.innerHTML = dangerouslySetInnerHTML.__html || "";
      } else if (children) {
        el.textContent = typeof children === "string" ? children : Array.isArray(children) ? children.join("") : "";
      }
      return el;
    }
    function isEqualNode(oldTag, newTag) {
      if (oldTag instanceof HTMLElement && newTag instanceof HTMLElement) {
        const nonce = newTag.getAttribute("nonce");
        if (nonce && !oldTag.getAttribute("nonce")) {
          const cloneTag = newTag.cloneNode(true);
          cloneTag.setAttribute("nonce", "");
          cloneTag.nonce = nonce;
          return nonce === oldTag.nonce && oldTag.isEqualNode(cloneTag);
        }
      }
      return oldTag.isEqualNode(newTag);
    }
    var updateElements;
    if (process.env.__NEXT_STRICT_NEXT_HEAD) {
      updateElements = (type, components) => {
        const headEl = document.querySelector("head");
        if (!headEl)
          return;
        const headMetaTags = headEl.querySelectorAll('meta[name="next-head"]') || [];
        const oldTags = [];
        if (type === "meta") {
          const metaCharset = headEl.querySelector("meta[charset]");
          if (metaCharset) {
            oldTags.push(metaCharset);
          }
        }
        for (let i = 0; i < headMetaTags.length; i++) {
          var ref;
          const metaTag = headMetaTags[i];
          const headTag = metaTag.nextSibling;
          if ((headTag == null ? void 0 : (ref = headTag.tagName) == null ? void 0 : ref.toLowerCase()) === type) {
            oldTags.push(headTag);
          }
        }
        const newTags = components.map(reactElementToDOM).filter((newTag) => {
          for (let k = 0, len = oldTags.length; k < len; k++) {
            const oldTag = oldTags[k];
            if (isEqualNode(oldTag, newTag)) {
              oldTags.splice(k, 1);
              return false;
            }
          }
          return true;
        });
        oldTags.forEach((t) => {
          var ref2;
          const metaTag = t.previousSibling;
          if (metaTag && metaTag.getAttribute("name") === "next-head") {
            var ref1;
            (ref1 = t.parentNode) == null ? void 0 : ref1.removeChild(metaTag);
          }
          (ref2 = t.parentNode) == null ? void 0 : ref2.removeChild(t);
        });
        newTags.forEach((t) => {
          var ref2;
          const meta = document.createElement("meta");
          meta.name = "next-head";
          meta.content = "1";
          if (!(((ref2 = t.tagName) == null ? void 0 : ref2.toLowerCase()) === "meta" && t.getAttribute("charset"))) {
            headEl.appendChild(meta);
          }
          headEl.appendChild(t);
        });
      };
    } else {
      updateElements = (type, components) => {
        const headEl = document.getElementsByTagName("head")[0];
        const headCountEl = headEl.querySelector("meta[name=next-head-count]");
        if (true) {
          if (!headCountEl) {
            console.error("Warning: next-head-count is missing. https://nextjs.org/docs/messages/next-head-count-missing");
            return;
          }
        }
        const headCount = Number(headCountEl.content);
        const oldTags = [];
        for (let i = 0, j = headCountEl.previousElementSibling; i < headCount; i++, j = (j == null ? void 0 : j.previousElementSibling) || null) {
          var ref;
          if ((j == null ? void 0 : (ref = j.tagName) == null ? void 0 : ref.toLowerCase()) === type) {
            oldTags.push(j);
          }
        }
        const newTags = components.map(reactElementToDOM).filter((newTag) => {
          for (let k = 0, len = oldTags.length; k < len; k++) {
            const oldTag = oldTags[k];
            if (isEqualNode(oldTag, newTag)) {
              oldTags.splice(k, 1);
              return false;
            }
          }
          return true;
        });
        oldTags.forEach((t) => {
          var ref2;
          return (ref2 = t.parentNode) == null ? void 0 : ref2.removeChild(t);
        });
        newTags.forEach((t) => headEl.insertBefore(t, headCountEl));
        headCountEl.content = (headCount - oldTags.length + newTags.length).toString();
      };
    }
    if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
      Object.defineProperty(exports.default, "__esModule", { value: true });
      Object.assign(exports.default, exports);
      module.exports = exports.default;
    }
  }
});

// ../../../../../../node_modules/next/dist/client/script.js
var require_script = __commonJS({
  "../../../../../../node_modules/next/dist/client/script.js"(exports, module) {
    "use client";
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.handleClientScriptLoad = handleClientScriptLoad;
    exports.initScriptLoader = initScriptLoader;
    exports.default = void 0;
    var _extends = require_extends().default;
    var _interop_require_default = require_interop_require_default().default;
    var _interop_require_wildcard = require_interop_require_wildcard().default;
    var _object_without_properties_loose = require_object_without_properties_loose().default;
    var _reactDom = _interop_require_default(require_react_dom());
    var _react = _interop_require_wildcard(require_react());
    var _headManagerContext = require_head_manager_context();
    var _headManager = require_head_manager();
    var _requestIdleCallback = require_request_idle_callback();
    var ScriptCache = /* @__PURE__ */ new Map();
    var LoadCache = /* @__PURE__ */ new Set();
    var ignoreProps = [
      "onLoad",
      "onReady",
      "dangerouslySetInnerHTML",
      "children",
      "onError",
      "strategy"
    ];
    var loadScript = (props) => {
      const { src, id, onLoad = () => {
      }, onReady = null, dangerouslySetInnerHTML, children = "", strategy = "afterInteractive", onError } = props;
      const cacheKey = id || src;
      if (cacheKey && LoadCache.has(cacheKey)) {
        return;
      }
      if (ScriptCache.has(src)) {
        LoadCache.add(cacheKey);
        ScriptCache.get(src).then(onLoad, onError);
        return;
      }
      const afterLoad = () => {
        if (onReady) {
          onReady();
        }
        LoadCache.add(cacheKey);
      };
      const el = document.createElement("script");
      const loadPromise = new Promise((resolve, reject) => {
        el.addEventListener("load", function(e) {
          resolve();
          if (onLoad) {
            onLoad.call(this, e);
          }
          afterLoad();
        });
        el.addEventListener("error", function(e) {
          reject(e);
        });
      }).catch(function(e) {
        if (onError) {
          onError(e);
        }
      });
      if (dangerouslySetInnerHTML) {
        el.innerHTML = dangerouslySetInnerHTML.__html || "";
        afterLoad();
      } else if (children) {
        el.textContent = typeof children === "string" ? children : Array.isArray(children) ? children.join("") : "";
        afterLoad();
      } else if (src) {
        el.src = src;
        ScriptCache.set(src, loadPromise);
      }
      for (const [k, value] of Object.entries(props)) {
        if (value === void 0 || ignoreProps.includes(k)) {
          continue;
        }
        const attr = _headManager.DOMAttributeNames[k] || k.toLowerCase();
        el.setAttribute(attr, value);
      }
      if (strategy === "worker") {
        el.setAttribute("type", "text/partytown");
      }
      el.setAttribute("data-nscript", strategy);
      document.body.appendChild(el);
    };
    function handleClientScriptLoad(props) {
      const { strategy = "afterInteractive" } = props;
      if (strategy === "lazyOnload") {
        window.addEventListener("load", () => {
          (0, _requestIdleCallback).requestIdleCallback(() => loadScript(props));
        });
      } else {
        loadScript(props);
      }
    }
    function loadLazyScript(props) {
      if (document.readyState === "complete") {
        (0, _requestIdleCallback).requestIdleCallback(() => loadScript(props));
      } else {
        window.addEventListener("load", () => {
          (0, _requestIdleCallback).requestIdleCallback(() => loadScript(props));
        });
      }
    }
    function addBeforeInteractiveToCache() {
      const scripts = [
        ...document.querySelectorAll('[data-nscript="beforeInteractive"]'),
        ...document.querySelectorAll('[data-nscript="beforePageRender"]')
      ];
      scripts.forEach((script) => {
        const cacheKey = script.id || script.getAttribute("src");
        LoadCache.add(cacheKey);
      });
    }
    function initScriptLoader(scriptLoaderItems) {
      scriptLoaderItems.forEach(handleClientScriptLoad);
      addBeforeInteractiveToCache();
    }
    function Script(props) {
      const { id, src = "", onLoad = () => {
      }, onReady = null, strategy = "afterInteractive", onError } = props, restProps = _object_without_properties_loose(props, [
        "id",
        "src",
        "onLoad",
        "onReady",
        "strategy",
        "onError"
      ]);
      const { updateScripts, scripts, getIsSsr, appDir, nonce } = (0, _react).useContext(_headManagerContext.HeadManagerContext);
      const hasOnReadyEffectCalled = (0, _react).useRef(false);
      (0, _react).useEffect(() => {
        const cacheKey = id || src;
        if (!hasOnReadyEffectCalled.current) {
          if (onReady && cacheKey && LoadCache.has(cacheKey)) {
            onReady();
          }
          hasOnReadyEffectCalled.current = true;
        }
      }, [
        onReady,
        id,
        src
      ]);
      const hasLoadScriptEffectCalled = (0, _react).useRef(false);
      (0, _react).useEffect(() => {
        if (!hasLoadScriptEffectCalled.current) {
          if (strategy === "afterInteractive") {
            loadScript(props);
          } else if (strategy === "lazyOnload") {
            loadLazyScript(props);
          }
          hasLoadScriptEffectCalled.current = true;
        }
      }, [
        props,
        strategy
      ]);
      if (strategy === "beforeInteractive" || strategy === "worker") {
        if (updateScripts) {
          scripts[strategy] = (scripts[strategy] || []).concat([
            _extends({
              id,
              src,
              onLoad,
              onReady,
              onError
            }, restProps)
          ]);
          updateScripts(scripts);
        } else if (getIsSsr && getIsSsr()) {
          LoadCache.add(id || src);
        } else if (getIsSsr && !getIsSsr()) {
          loadScript(props);
        }
      }
      if (appDir) {
        if (strategy === "beforeInteractive") {
          if (!src) {
            if (restProps.dangerouslySetInnerHTML) {
              restProps.children = restProps.dangerouslySetInnerHTML.__html;
              delete restProps.dangerouslySetInnerHTML;
            }
            return _react.default.createElement("script", {
              nonce,
              dangerouslySetInnerHTML: {
                __html: `(self.__next_s=self.__next_s||[]).push(${JSON.stringify([
                  0,
                  _extends({}, restProps)
                ])})`
              }
            });
          }
          _reactDom.default.preload(src, restProps.integrity ? {
            as: "script",
            integrity: restProps.integrity
          } : {
            as: "script"
          });
          return _react.default.createElement("script", {
            nonce,
            dangerouslySetInnerHTML: {
              __html: `(self.__next_s=self.__next_s||[]).push(${JSON.stringify([
                src
              ])})`
            }
          });
        } else if (strategy === "afterInteractive") {
          if (src) {
            _reactDom.default.preload(src, restProps.integrity ? {
              as: "script",
              integrity: restProps.integrity
            } : {
              as: "script"
            });
          }
        }
      }
      return null;
    }
    Object.defineProperty(Script, "__nextScript", {
      value: true
    });
    var _default = Script;
    exports.default = _default;
    if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
      Object.defineProperty(exports.default, "__esModule", { value: true });
      Object.assign(exports.default, exports);
      module.exports = exports.default;
    }
  }
});

// ../../../../../../node_modules/next/dist/shared/lib/is-plain-object.js
var require_is_plain_object = __commonJS({
  "../../../../../../node_modules/next/dist/shared/lib/is-plain-object.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getObjectClassLabel = getObjectClassLabel;
    exports.isPlainObject = isPlainObject;
    function getObjectClassLabel(value) {
      return Object.prototype.toString.call(value);
    }
    function isPlainObject(value) {
      if (getObjectClassLabel(value) !== "[object Object]") {
        return false;
      }
      const prototype = Object.getPrototypeOf(value);
      return prototype === null || prototype.hasOwnProperty("isPrototypeOf");
    }
  }
});

// ../../../../../../node_modules/next/dist/lib/is-error.js
var require_is_error = __commonJS({
  "../../../../../../node_modules/next/dist/lib/is-error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isError;
    exports.getProperError = getProperError;
    var _isPlainObject = require_is_plain_object();
    function isError(err) {
      return typeof err === "object" && err !== null && "name" in err && "message" in err;
    }
    function getProperError(err) {
      if (isError(err)) {
        return err;
      }
      if (true) {
        if (typeof err === "undefined") {
          return new Error("An undefined error was thrown, see here for more info: https://nextjs.org/docs/messages/threw-undefined");
        }
        if (err === null) {
          return new Error("A null error was thrown, see here for more info: https://nextjs.org/docs/messages/threw-undefined");
        }
      }
      return new Error((0, _isPlainObject).isPlainObject(err) ? JSON.stringify(err) : err + "");
    }
  }
});

// ../../../../../../node_modules/next/dist/shared/lib/router/utils/sorted-routes.js
var require_sorted_routes = __commonJS({
  "../../../../../../node_modules/next/dist/shared/lib/router/utils/sorted-routes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getSortedRoutes = getSortedRoutes;
    var UrlNode = class {
      insert(urlPath) {
        this._insert(urlPath.split("/").filter(Boolean), [], false);
      }
      smoosh() {
        return this._smoosh();
      }
      _smoosh(prefix = "/") {
        const childrenPaths = [
          ...this.children.keys()
        ].sort();
        if (this.slugName !== null) {
          childrenPaths.splice(childrenPaths.indexOf("[]"), 1);
        }
        if (this.restSlugName !== null) {
          childrenPaths.splice(childrenPaths.indexOf("[...]"), 1);
        }
        if (this.optionalRestSlugName !== null) {
          childrenPaths.splice(childrenPaths.indexOf("[[...]]"), 1);
        }
        const routes = childrenPaths.map((c) => this.children.get(c)._smoosh(`${prefix}${c}/`)).reduce((prev, curr) => [
          ...prev,
          ...curr
        ], []);
        if (this.slugName !== null) {
          routes.push(...this.children.get("[]")._smoosh(`${prefix}[${this.slugName}]/`));
        }
        if (!this.placeholder) {
          const r = prefix === "/" ? "/" : prefix.slice(0, -1);
          if (this.optionalRestSlugName != null) {
            throw new Error(`You cannot define a route with the same specificity as a optional catch-all route ("${r}" and "${r}[[...${this.optionalRestSlugName}]]").`);
          }
          routes.unshift(r);
        }
        if (this.restSlugName !== null) {
          routes.push(...this.children.get("[...]")._smoosh(`${prefix}[...${this.restSlugName}]/`));
        }
        if (this.optionalRestSlugName !== null) {
          routes.push(...this.children.get("[[...]]")._smoosh(`${prefix}[[...${this.optionalRestSlugName}]]/`));
        }
        return routes;
      }
      _insert(urlPaths, slugNames, isCatchAll) {
        if (urlPaths.length === 0) {
          this.placeholder = false;
          return;
        }
        if (isCatchAll) {
          throw new Error(`Catch-all must be the last part of the URL.`);
        }
        let nextSegment = urlPaths[0];
        if (nextSegment.startsWith("[") && nextSegment.endsWith("]")) {
          let handleSlug = function(previousSlug, nextSlug) {
            if (previousSlug !== null) {
              if (previousSlug !== nextSlug) {
                throw new Error(`You cannot use different slug names for the same dynamic path ('${previousSlug}' !== '${nextSlug}').`);
              }
            }
            slugNames.forEach((slug) => {
              if (slug === nextSlug) {
                throw new Error(`You cannot have the same slug name "${nextSlug}" repeat within a single dynamic path`);
              }
              if (slug.replace(/\W/g, "") === nextSegment.replace(/\W/g, "")) {
                throw new Error(`You cannot have the slug names "${slug}" and "${nextSlug}" differ only by non-word symbols within a single dynamic path`);
              }
            });
            slugNames.push(nextSlug);
          };
          let segmentName = nextSegment.slice(1, -1);
          let isOptional = false;
          if (segmentName.startsWith("[") && segmentName.endsWith("]")) {
            segmentName = segmentName.slice(1, -1);
            isOptional = true;
          }
          if (segmentName.startsWith("...")) {
            segmentName = segmentName.substring(3);
            isCatchAll = true;
          }
          if (segmentName.startsWith("[") || segmentName.endsWith("]")) {
            throw new Error(`Segment names may not start or end with extra brackets ('${segmentName}').`);
          }
          if (segmentName.startsWith(".")) {
            throw new Error(`Segment names may not start with erroneous periods ('${segmentName}').`);
          }
          if (isCatchAll) {
            if (isOptional) {
              if (this.restSlugName != null) {
                throw new Error(`You cannot use both an required and optional catch-all route at the same level ("[...${this.restSlugName}]" and "${urlPaths[0]}" ).`);
              }
              handleSlug(this.optionalRestSlugName, segmentName);
              this.optionalRestSlugName = segmentName;
              nextSegment = "[[...]]";
            } else {
              if (this.optionalRestSlugName != null) {
                throw new Error(`You cannot use both an optional and required catch-all route at the same level ("[[...${this.optionalRestSlugName}]]" and "${urlPaths[0]}").`);
              }
              handleSlug(this.restSlugName, segmentName);
              this.restSlugName = segmentName;
              nextSegment = "[...]";
            }
          } else {
            if (isOptional) {
              throw new Error(`Optional route parameters are not yet supported ("${urlPaths[0]}").`);
            }
            handleSlug(this.slugName, segmentName);
            this.slugName = segmentName;
            nextSegment = "[]";
          }
        }
        if (!this.children.has(nextSegment)) {
          this.children.set(nextSegment, new UrlNode());
        }
        this.children.get(nextSegment)._insert(urlPaths.slice(1), slugNames, isCatchAll);
      }
      constructor() {
        this.placeholder = true;
        this.children = /* @__PURE__ */ new Map();
        this.slugName = null;
        this.restSlugName = null;
        this.optionalRestSlugName = null;
      }
    };
    function getSortedRoutes(normalizedPages) {
      const root = new UrlNode();
      normalizedPages.forEach((pagePath) => root.insert(pagePath));
      return root.smoosh();
    }
  }
});

// ../../../../../../node_modules/next/dist/shared/lib/router/utils/is-dynamic.js
var require_is_dynamic = __commonJS({
  "../../../../../../node_modules/next/dist/shared/lib/router/utils/is-dynamic.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isDynamicRoute = isDynamicRoute;
    var TEST_ROUTE = /\/\[[^/]+?\](?=\/|$)/;
    function isDynamicRoute(route) {
      return TEST_ROUTE.test(route);
    }
  }
});

// ../../../../../../node_modules/next/dist/shared/lib/router/utils/index.js
var require_utils = __commonJS({
  "../../../../../../node_modules/next/dist/shared/lib/router/utils/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "getSortedRoutes", {
      enumerable: true,
      get: function() {
        return _sortedRoutes.getSortedRoutes;
      }
    });
    Object.defineProperty(exports, "isDynamicRoute", {
      enumerable: true,
      get: function() {
        return _isDynamic.isDynamicRoute;
      }
    });
    var _sortedRoutes = require_sorted_routes();
    var _isDynamic = require_is_dynamic();
  }
});

// ../../../../../../node_modules/next/dist/shared/lib/page-path/normalize-path-sep.js
var require_normalize_path_sep = __commonJS({
  "../../../../../../node_modules/next/dist/shared/lib/page-path/normalize-path-sep.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.normalizePathSep = normalizePathSep;
    function normalizePathSep(path) {
      return path.replace(/\\/g, "/");
    }
  }
});

// ../../../../../../node_modules/next/dist/shared/lib/page-path/denormalize-page-path.js
var require_denormalize_page_path = __commonJS({
  "../../../../../../node_modules/next/dist/shared/lib/page-path/denormalize-page-path.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.denormalizePagePath = denormalizePagePath;
    var _utils = require_utils();
    var _normalizePathSep = require_normalize_path_sep();
    function denormalizePagePath(page) {
      let _page = (0, _normalizePathSep).normalizePathSep(page);
      return _page.startsWith("/index/") && !(0, _utils).isDynamicRoute(_page) ? _page.slice(6) : _page !== "/index" ? _page : "/";
    }
  }
});

// ../../../../../../node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js
var require_normalize_locale_path = __commonJS({
  "../../../../../../node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.normalizeLocalePath = normalizeLocalePath;
    function normalizeLocalePath(pathname, locales) {
      let detectedLocale;
      const pathnameParts = pathname.split("/");
      (locales || []).some((locale) => {
        if (pathnameParts[1] && pathnameParts[1].toLowerCase() === locale.toLowerCase()) {
          detectedLocale = locale;
          pathnameParts.splice(1, 1);
          pathname = pathnameParts.join("/") || "/";
          return true;
        }
        return false;
      });
      return {
        pathname,
        detectedLocale
      };
    }
  }
});

// ../../../../../../node_modules/next/dist/shared/lib/mitt.js
var require_mitt = __commonJS({
  "../../../../../../node_modules/next/dist/shared/lib/mitt.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = mitt;
    function mitt() {
      const all = /* @__PURE__ */ Object.create(null);
      return {
        on(type, handler) {
          (all[type] || (all[type] = [])).push(handler);
        },
        off(type, handler) {
          if (all[type]) {
            all[type].splice(all[type].indexOf(handler) >>> 0, 1);
          }
        },
        emit(type, ...evts) {
          (all[type] || []).slice().map((handler) => {
            handler(...evts);
          });
        }
      };
    }
  }
});

// ../../../../../../node_modules/next/dist/shared/lib/utils.js
var require_utils2 = __commonJS({
  "../../../../../../node_modules/next/dist/shared/lib/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.execOnce = execOnce;
    exports.getLocationOrigin = getLocationOrigin;
    exports.getURL = getURL;
    exports.getDisplayName = getDisplayName;
    exports.isResSent = isResSent;
    exports.normalizeRepeatedSlashes = normalizeRepeatedSlashes;
    exports.loadGetInitialProps = loadGetInitialProps;
    exports.ST = exports.SP = exports.isAbsoluteUrl = exports.WEB_VITALS = void 0;
    var _async_to_generator = require_async_to_generator().default;
    var WEB_VITALS = [
      "CLS",
      "FCP",
      "FID",
      "INP",
      "LCP",
      "TTFB"
    ];
    exports.WEB_VITALS = WEB_VITALS;
    function execOnce(fn) {
      let used = false;
      let result;
      return (...args) => {
        if (!used) {
          used = true;
          result = fn(...args);
        }
        return result;
      };
    }
    var ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\d+\-.]*?:/;
    var isAbsoluteUrl = (url) => ABSOLUTE_URL_REGEX.test(url);
    exports.isAbsoluteUrl = isAbsoluteUrl;
    function getLocationOrigin() {
      const { protocol, hostname, port } = window.location;
      return `${protocol}//${hostname}${port ? ":" + port : ""}`;
    }
    function getURL() {
      const { href } = window.location;
      const origin = getLocationOrigin();
      return href.substring(origin.length);
    }
    function getDisplayName(Component) {
      return typeof Component === "string" ? Component : Component.displayName || Component.name || "Unknown";
    }
    function isResSent(res) {
      return res.finished || res.headersSent;
    }
    function normalizeRepeatedSlashes(url) {
      const urlParts = url.split("?");
      const urlNoQuery = urlParts[0];
      return urlNoQuery.replace(/\\/g, "/").replace(/\/\/+/g, "/") + (urlParts[1] ? `?${urlParts.slice(1).join("?")}` : "");
    }
    function loadGetInitialProps(App, ctx) {
      return _loadGetInitialProps.apply(this, arguments);
    }
    function _loadGetInitialProps() {
      _loadGetInitialProps = _async_to_generator(function* (App, ctx) {
        if (true) {
          var ref;
          if ((ref = App.prototype) == null ? void 0 : ref.getInitialProps) {
            const message = `"${getDisplayName(App)}.getInitialProps()" is defined as an instance method - visit https://nextjs.org/docs/messages/get-initial-props-as-an-instance-method for more information.`;
            throw new Error(message);
          }
        }
        const res = ctx.res || ctx.ctx && ctx.ctx.res;
        if (!App.getInitialProps) {
          if (ctx.ctx && ctx.Component) {
            return {
              pageProps: yield loadGetInitialProps(ctx.Component, ctx.ctx)
            };
          }
          return {};
        }
        const props = yield App.getInitialProps(ctx);
        if (res && isResSent(res)) {
          return props;
        }
        if (!props) {
          const message = `"${getDisplayName(App)}.getInitialProps()" should resolve to an object. But found "${props}" instead.`;
          throw new Error(message);
        }
        if (true) {
          if (Object.keys(props).length === 0 && !ctx.ctx) {
            console.warn(`${getDisplayName(App)} returned an empty object from \`getInitialProps\`. This de-optimizes and prevents automatic static optimization. https://nextjs.org/docs/messages/empty-object-getInitialProps`);
          }
        }
        return props;
      });
      return _loadGetInitialProps.apply(this, arguments);
    }
    var SP = typeof performance !== "undefined";
    exports.SP = SP;
    var ST = SP && [
      "mark",
      "measure",
      "getEntriesByName"
    ].every((method) => typeof performance[method] === "function");
    exports.ST = ST;
    var DecodeError = class extends Error {
    };
    exports.DecodeError = DecodeError;
    var NormalizeError = class extends Error {
    };
    exports.NormalizeError = NormalizeError;
    var PageNotFoundError = class extends Error {
      constructor(page) {
        super();
        this.code = "ENOENT";
        this.name = "PageNotFoundError";
        this.message = `Cannot find module for page: ${page}`;
      }
    };
    exports.PageNotFoundError = PageNotFoundError;
    var MissingStaticPage = class extends Error {
      constructor(page, message) {
        super();
        this.message = `Failed to load static file for page: ${page} ${message}`;
      }
    };
    exports.MissingStaticPage = MissingStaticPage;
    var MiddlewareNotFoundError = class extends Error {
      constructor() {
        super();
        this.code = "ENOENT";
        this.message = `Cannot find the middleware module`;
      }
    };
    exports.MiddlewareNotFoundError = MiddlewareNotFoundError;
  }
});

// ../../../../../../node_modules/next/dist/shared/lib/router/utils/querystring.js
var require_querystring = __commonJS({
  "../../../../../../node_modules/next/dist/shared/lib/router/utils/querystring.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.searchParamsToUrlQuery = searchParamsToUrlQuery;
    exports.urlQueryToSearchParams = urlQueryToSearchParams;
    exports.assign = assign;
    function searchParamsToUrlQuery(searchParams) {
      const query = {};
      searchParams.forEach((value, key) => {
        if (typeof query[key] === "undefined") {
          query[key] = value;
        } else if (Array.isArray(query[key])) {
          query[key].push(value);
        } else {
          query[key] = [
            query[key],
            value
          ];
        }
      });
      return query;
    }
    function stringifyUrlQueryParam(param) {
      if (typeof param === "string" || typeof param === "number" && !isNaN(param) || typeof param === "boolean") {
        return String(param);
      } else {
        return "";
      }
    }
    function urlQueryToSearchParams(urlQuery) {
      const result = new URLSearchParams();
      Object.entries(urlQuery).forEach(([key, value]) => {
        if (Array.isArray(value)) {
          value.forEach((item) => result.append(key, stringifyUrlQueryParam(item)));
        } else {
          result.set(key, stringifyUrlQueryParam(value));
        }
      });
      return result;
    }
    function assign(target, ...searchParamsList) {
      searchParamsList.forEach((searchParams) => {
        Array.from(searchParams.keys()).forEach((key) => target.delete(key));
        searchParams.forEach((value, key) => target.append(key, value));
      });
      return target;
    }
  }
});

// ../../../../../../node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js
var require_parse_relative_url = __commonJS({
  "../../../../../../node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.parseRelativeUrl = parseRelativeUrl;
    var _utils = require_utils2();
    var _querystring = require_querystring();
    function parseRelativeUrl(url, base) {
      const globalBase = new URL(typeof window === "undefined" ? "http://n" : (0, _utils).getLocationOrigin());
      const resolvedBase = base ? new URL(base, globalBase) : url.startsWith(".") ? new URL(typeof window === "undefined" ? "http://n" : window.location.href) : globalBase;
      const { pathname, searchParams, search, hash, href, origin } = new URL(url, resolvedBase);
      if (origin !== globalBase.origin) {
        throw new Error(`invariant: invalid relative URL, router received ${url}`);
      }
      return {
        pathname,
        query: (0, _querystring).searchParamsToUrlQuery(searchParams),
        search,
        hash,
        href: href.slice(globalBase.origin.length)
      };
    }
  }
});

// ../../../../../../node_modules/next/dist/compiled/path-to-regexp/index.js
var require_path_to_regexp = __commonJS({
  "../../../../../../node_modules/next/dist/compiled/path-to-regexp/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function lexer(str) {
      var tokens = [];
      var i = 0;
      while (i < str.length) {
        var char = str[i];
        if (char === "*" || char === "+" || char === "?") {
          tokens.push({ type: "MODIFIER", index: i, value: str[i++] });
          continue;
        }
        if (char === "\\") {
          tokens.push({ type: "ESCAPED_CHAR", index: i++, value: str[i++] });
          continue;
        }
        if (char === "{") {
          tokens.push({ type: "OPEN", index: i, value: str[i++] });
          continue;
        }
        if (char === "}") {
          tokens.push({ type: "CLOSE", index: i, value: str[i++] });
          continue;
        }
        if (char === ":") {
          var name = "";
          var j = i + 1;
          while (j < str.length) {
            var code = str.charCodeAt(j);
            if (
              // `0-9`
              code >= 48 && code <= 57 || // `A-Z`
              code >= 65 && code <= 90 || // `a-z`
              code >= 97 && code <= 122 || // `_`
              code === 95
            ) {
              name += str[j++];
              continue;
            }
            break;
          }
          if (!name)
            throw new TypeError("Missing parameter name at " + i);
          tokens.push({ type: "NAME", index: i, value: name });
          i = j;
          continue;
        }
        if (char === "(") {
          var count = 1;
          var pattern = "";
          var j = i + 1;
          if (str[j] === "?") {
            throw new TypeError('Pattern cannot start with "?" at ' + j);
          }
          while (j < str.length) {
            if (str[j] === "\\") {
              pattern += str[j++] + str[j++];
              continue;
            }
            if (str[j] === ")") {
              count--;
              if (count === 0) {
                j++;
                break;
              }
            } else if (str[j] === "(") {
              count++;
              if (str[j + 1] !== "?") {
                throw new TypeError("Capturing groups are not allowed at " + j);
              }
            }
            pattern += str[j++];
          }
          if (count)
            throw new TypeError("Unbalanced pattern at " + i);
          if (!pattern)
            throw new TypeError("Missing pattern at " + i);
          tokens.push({ type: "PATTERN", index: i, value: pattern });
          i = j;
          continue;
        }
        tokens.push({ type: "CHAR", index: i, value: str[i++] });
      }
      tokens.push({ type: "END", index: i, value: "" });
      return tokens;
    }
    function parse(str, options) {
      if (options === void 0) {
        options = {};
      }
      var tokens = lexer(str);
      var _a = options.prefixes, prefixes = _a === void 0 ? "./" : _a;
      var defaultPattern = "[^" + escapeString(options.delimiter || "/#?") + "]+?";
      var result = [];
      var key = 0;
      var i = 0;
      var path = "";
      var tryConsume = function(type) {
        if (i < tokens.length && tokens[i].type === type)
          return tokens[i++].value;
      };
      var mustConsume = function(type) {
        var value2 = tryConsume(type);
        if (value2 !== void 0)
          return value2;
        var _a2 = tokens[i], nextType = _a2.type, index = _a2.index;
        throw new TypeError("Unexpected " + nextType + " at " + index + ", expected " + type);
      };
      var consumeText = function() {
        var result2 = "";
        var value2;
        while (value2 = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR")) {
          result2 += value2;
        }
        return result2;
      };
      while (i < tokens.length) {
        var char = tryConsume("CHAR");
        var name = tryConsume("NAME");
        var pattern = tryConsume("PATTERN");
        if (name || pattern) {
          var prefix = char || "";
          if (prefixes.indexOf(prefix) === -1) {
            path += prefix;
            prefix = "";
          }
          if (path) {
            result.push(path);
            path = "";
          }
          result.push({
            name: name || key++,
            prefix,
            suffix: "",
            pattern: pattern || defaultPattern,
            modifier: tryConsume("MODIFIER") || ""
          });
          continue;
        }
        var value = char || tryConsume("ESCAPED_CHAR");
        if (value) {
          path += value;
          continue;
        }
        if (path) {
          result.push(path);
          path = "";
        }
        var open = tryConsume("OPEN");
        if (open) {
          var prefix = consumeText();
          var name_1 = tryConsume("NAME") || "";
          var pattern_1 = tryConsume("PATTERN") || "";
          var suffix = consumeText();
          mustConsume("CLOSE");
          result.push({
            name: name_1 || (pattern_1 ? key++ : ""),
            pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,
            prefix,
            suffix,
            modifier: tryConsume("MODIFIER") || ""
          });
          continue;
        }
        mustConsume("END");
      }
      return result;
    }
    exports.parse = parse;
    function compile(str, options) {
      return tokensToFunction(parse(str, options), options);
    }
    exports.compile = compile;
    function tokensToFunction(tokens, options) {
      if (options === void 0) {
        options = {};
      }
      var reFlags = flags(options);
      var _a = options.encode, encode = _a === void 0 ? function(x) {
        return x;
      } : _a, _b = options.validate, validate = _b === void 0 ? true : _b;
      var matches = tokens.map(function(token) {
        if (typeof token === "object") {
          return new RegExp("^(?:" + token.pattern + ")$", reFlags);
        }
      });
      return function(data) {
        var path = "";
        for (var i = 0; i < tokens.length; i++) {
          var token = tokens[i];
          if (typeof token === "string") {
            path += token;
            continue;
          }
          var value = data ? data[token.name] : void 0;
          var optional = token.modifier === "?" || token.modifier === "*";
          var repeat = token.modifier === "*" || token.modifier === "+";
          if (Array.isArray(value)) {
            if (!repeat) {
              throw new TypeError('Expected "' + token.name + '" to not repeat, but got an array');
            }
            if (value.length === 0) {
              if (optional)
                continue;
              throw new TypeError('Expected "' + token.name + '" to not be empty');
            }
            for (var j = 0; j < value.length; j++) {
              var segment = encode(value[j], token);
              if (validate && !matches[i].test(segment)) {
                throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but got "' + segment + '"');
              }
              path += token.prefix + segment + token.suffix;
            }
            continue;
          }
          if (typeof value === "string" || typeof value === "number") {
            var segment = encode(String(value), token);
            if (validate && !matches[i].test(segment)) {
              throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but got "' + segment + '"');
            }
            path += token.prefix + segment + token.suffix;
            continue;
          }
          if (optional)
            continue;
          var typeOfMessage = repeat ? "an array" : "a string";
          throw new TypeError('Expected "' + token.name + '" to be ' + typeOfMessage);
        }
        return path;
      };
    }
    exports.tokensToFunction = tokensToFunction;
    function match(str, options) {
      var keys = [];
      var re = pathToRegexp(str, keys, options);
      return regexpToFunction(re, keys, options);
    }
    exports.match = match;
    function regexpToFunction(re, keys, options) {
      if (options === void 0) {
        options = {};
      }
      var _a = options.decode, decode = _a === void 0 ? function(x) {
        return x;
      } : _a;
      return function(pathname) {
        var m = re.exec(pathname);
        if (!m)
          return false;
        var path = m[0], index = m.index;
        var params = /* @__PURE__ */ Object.create(null);
        var _loop_1 = function(i2) {
          if (m[i2] === void 0)
            return "continue";
          var key = keys[i2 - 1];
          if (key.modifier === "*" || key.modifier === "+") {
            params[key.name] = m[i2].split(key.prefix + key.suffix).map(function(value) {
              return decode(value, key);
            });
          } else {
            params[key.name] = decode(m[i2], key);
          }
        };
        for (var i = 1; i < m.length; i++) {
          _loop_1(i);
        }
        return { path, index, params };
      };
    }
    exports.regexpToFunction = regexpToFunction;
    function escapeString(str) {
      return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
    }
    function flags(options) {
      return options && options.sensitive ? "" : "i";
    }
    function regexpToRegexp(path, keys) {
      if (!keys)
        return path;
      var groups = path.source.match(/\((?!\?)/g);
      if (groups) {
        for (var i = 0; i < groups.length; i++) {
          keys.push({
            name: i,
            prefix: "",
            suffix: "",
            modifier: "",
            pattern: ""
          });
        }
      }
      return path;
    }
    function arrayToRegexp(paths, keys, options) {
      var parts = paths.map(function(path) {
        return pathToRegexp(path, keys, options).source;
      });
      return new RegExp("(?:" + parts.join("|") + ")", flags(options));
    }
    function stringToRegexp(path, keys, options) {
      return tokensToRegexp(parse(path, options), keys, options);
    }
    function tokensToRegexp(tokens, keys, options) {
      if (options === void 0) {
        options = {};
      }
      var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function(x) {
        return x;
      } : _d;
      var endsWith = "[" + escapeString(options.endsWith || "") + "]|$";
      var delimiter = "[" + escapeString(options.delimiter || "/#?") + "]";
      var route = start ? "^" : "";
      for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
        var token = tokens_1[_i];
        if (typeof token === "string") {
          route += escapeString(encode(token));
        } else {
          var prefix = escapeString(encode(token.prefix));
          var suffix = escapeString(encode(token.suffix));
          if (token.pattern) {
            if (keys)
              keys.push(token);
            if (prefix || suffix) {
              if (token.modifier === "+" || token.modifier === "*") {
                var mod = token.modifier === "*" ? "?" : "";
                route += "(?:" + prefix + "((?:" + token.pattern + ")(?:" + suffix + prefix + "(?:" + token.pattern + "))*)" + suffix + ")" + mod;
              } else {
                route += "(?:" + prefix + "(" + token.pattern + ")" + suffix + ")" + token.modifier;
              }
            } else {
              route += "(" + token.pattern + ")" + token.modifier;
            }
          } else {
            route += "(?:" + prefix + suffix + ")" + token.modifier;
          }
        }
      }
      if (end) {
        if (!strict)
          route += delimiter + "?";
        route += !options.endsWith ? "$" : "(?=" + endsWith + ")";
      } else {
        var endToken = tokens[tokens.length - 1];
        var isEndDelimited = typeof endToken === "string" ? delimiter.indexOf(endToken[endToken.length - 1]) > -1 : (
          // tslint:disable-next-line
          endToken === void 0
        );
        if (!strict) {
          route += "(?:" + delimiter + "(?=" + endsWith + "))?";
        }
        if (!isEndDelimited) {
          route += "(?=" + delimiter + "|" + endsWith + ")";
        }
      }
      return new RegExp(route, flags(options));
    }
    exports.tokensToRegexp = tokensToRegexp;
    function pathToRegexp(path, keys, options) {
      if (path instanceof RegExp)
        return regexpToRegexp(path, keys);
      if (Array.isArray(path))
        return arrayToRegexp(path, keys, options);
      return stringToRegexp(path, keys, options);
    }
    exports.pathToRegexp = pathToRegexp;
  }
});

// ../../../../../../node_modules/next/dist/shared/lib/router/utils/path-match.js
var require_path_match = __commonJS({
  "../../../../../../node_modules/next/dist/shared/lib/router/utils/path-match.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getPathMatch = getPathMatch;
    var _extends = require_extends().default;
    var _pathToRegexp = require_path_to_regexp();
    function getPathMatch(path, options) {
      const keys = [];
      const regexp = (0, _pathToRegexp).pathToRegexp(path, keys, {
        delimiter: "/",
        sensitive: false,
        strict: options == null ? void 0 : options.strict
      });
      const matcher = (0, _pathToRegexp).regexpToFunction((options == null ? void 0 : options.regexModifier) ? new RegExp(options.regexModifier(regexp.source), regexp.flags) : regexp, keys);
      return (pathname, params) => {
        const res = pathname == null ? false : matcher(pathname);
        if (!res) {
          return false;
        }
        if (options == null ? void 0 : options.removeUnnamedParams) {
          for (const key of keys) {
            if (typeof key.name === "number") {
              delete res.params[key.name];
            }
          }
        }
        return _extends({}, params, res.params);
      };
    }
  }
});

// ../../../../../../node_modules/next/dist/shared/lib/escape-regexp.js
var require_escape_regexp = __commonJS({
  "../../../../../../node_modules/next/dist/shared/lib/escape-regexp.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.escapeStringRegexp = escapeStringRegexp;
    var reHasRegExp = /[|\\{}()[\]^$+*?.-]/;
    var reReplaceRegExp = /[|\\{}()[\]^$+*?.-]/g;
    function escapeStringRegexp(str) {
      if (reHasRegExp.test(str)) {
        return str.replace(reReplaceRegExp, "\\$&");
      }
      return str;
    }
  }
});

// ../../../../../../node_modules/next/dist/shared/lib/router/utils/parse-url.js
var require_parse_url = __commonJS({
  "../../../../../../node_modules/next/dist/shared/lib/router/utils/parse-url.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.parseUrl = parseUrl;
    var _querystring = require_querystring();
    var _parseRelativeUrl = require_parse_relative_url();
    function parseUrl(url) {
      if (url.startsWith("/")) {
        return (0, _parseRelativeUrl).parseRelativeUrl(url);
      }
      const parsedURL = new URL(url);
      return {
        hash: parsedURL.hash,
        hostname: parsedURL.hostname,
        href: parsedURL.href,
        pathname: parsedURL.pathname,
        port: parsedURL.port,
        protocol: parsedURL.protocol,
        query: (0, _querystring).searchParamsToUrlQuery(parsedURL.searchParams),
        search: parsedURL.search
      };
    }
  }
});

// ../../../../../../node_modules/next/dist/shared/lib/page-path/ensure-leading-slash.js
var require_ensure_leading_slash = __commonJS({
  "../../../../../../node_modules/next/dist/shared/lib/page-path/ensure-leading-slash.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ensureLeadingSlash = ensureLeadingSlash;
    function ensureLeadingSlash(path) {
      return path.startsWith("/") ? path : `/${path}`;
    }
  }
});

// ../../../../../../node_modules/next/dist/shared/lib/router/utils/app-paths.js
var require_app_paths = __commonJS({
  "../../../../../../node_modules/next/dist/shared/lib/router/utils/app-paths.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.normalizeAppPath = normalizeAppPath;
    exports.normalizeRscPath = normalizeRscPath;
    var _ensureLeadingSlash = require_ensure_leading_slash();
    function normalizeAppPath(route) {
      return (0, _ensureLeadingSlash).ensureLeadingSlash(route.split("/").reduce((pathname, segment, index, segments) => {
        if (!segment) {
          return pathname;
        }
        if (segment.startsWith("(") && segment.endsWith(")")) {
          return pathname;
        }
        if (segment.startsWith("@")) {
          return pathname;
        }
        if ((segment === "page" || segment === "route") && index === segments.length - 1) {
          return pathname;
        }
        return `${pathname}/${segment}`;
      }, ""));
    }
    function normalizeRscPath(pathname, enabled) {
      return enabled ? pathname.replace(
        /\.rsc($|\?)/,
        // $1 ensures `?` is preserved
        "$1"
      ) : pathname;
    }
  }
});

// ../../../../../../node_modules/next/dist/server/future/helpers/interception-routes.js
var require_interception_routes = __commonJS({
  "../../../../../../node_modules/next/dist/server/future/helpers/interception-routes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isInterceptionRouteAppPath = isInterceptionRouteAppPath;
    exports.extractInterceptionRouteInformation = extractInterceptionRouteInformation;
    exports.INTERCEPTION_ROUTE_MARKERS = void 0;
    var _appPaths = require_app_paths();
    var INTERCEPTION_ROUTE_MARKERS = [
      "(..)(..)",
      "(..)",
      "(...)"
    ];
    exports.INTERCEPTION_ROUTE_MARKERS = INTERCEPTION_ROUTE_MARKERS;
    function isInterceptionRouteAppPath(path) {
      return path.split("/").find((segment) => INTERCEPTION_ROUTE_MARKERS.find((m) => segment.startsWith(m))) !== void 0;
    }
    function extractInterceptionRouteInformation(path) {
      let interceptingRoute, marker, interceptedRoute;
      for (const segment of path.split("/")) {
        marker = INTERCEPTION_ROUTE_MARKERS.find((m) => segment.startsWith(m));
        if (marker) {
          [interceptingRoute, interceptedRoute] = path.split(marker, 2);
          break;
        }
      }
      if (!interceptingRoute || !marker || !interceptedRoute) {
        throw new Error(`Invalid interception route: ${path}. Must be in the format /<intercepting route>/(..|...|..)(..)/<intercepted route>`);
      }
      interceptingRoute = interceptingRoute.slice(0, -1);
      interceptingRoute = (0, _appPaths).normalizeAppPath(interceptingRoute);
      if (marker === "(..)") {
        interceptedRoute = interceptingRoute.split("/").slice(0, -1).join("/") + "/" + interceptedRoute;
      }
      if (marker === "(...)") {
        interceptedRoute = "/" + interceptedRoute;
      }
      if (marker === "(..)(..)") {
        interceptedRoute = interceptingRoute.split("/").slice(0, -2).join("/") + "/" + interceptedRoute;
      }
      return {
        interceptingRoute,
        interceptedRoute
      };
    }
  }
});

// ../../../../../../node_modules/next/dist/shared/lib/router/utils/prepare-destination.js
var require_prepare_destination = __commonJS({
  "../../../../../../node_modules/next/dist/shared/lib/router/utils/prepare-destination.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.matchHas = matchHas;
    exports.compileNonPath = compileNonPath;
    exports.prepareDestination = prepareDestination;
    var _extends = require_extends().default;
    var _pathToRegexp = require_path_to_regexp();
    var _escapeRegexp = require_escape_regexp();
    var _parseUrl = require_parse_url();
    var _interceptionRoutes = require_interception_routes();
    function getSafeParamName(paramName) {
      let newParamName = "";
      for (let i = 0; i < paramName.length; i++) {
        const charCode = paramName.charCodeAt(i);
        if (charCode > 64 && charCode < 91 || charCode > 96 && charCode < 123) {
          newParamName += paramName[i];
        }
      }
      return newParamName;
    }
    function escapeSegment(str, segmentName) {
      return str.replace(new RegExp(`:${(0, _escapeRegexp).escapeStringRegexp(segmentName)}`, "g"), `__ESC_COLON_${segmentName}`);
    }
    function unescapeSegments(str) {
      return str.replace(/__ESC_COLON_/gi, ":");
    }
    function matchHas(req, query, has = [], missing = []) {
      const params = {};
      const hasMatch = (hasItem) => {
        let value;
        let key = hasItem.key;
        switch (hasItem.type) {
          case "header": {
            key = key.toLowerCase();
            value = req.headers[key];
            break;
          }
          case "cookie": {
            value = req.cookies[hasItem.key];
            break;
          }
          case "query": {
            value = query[key];
            break;
          }
          case "host": {
            const { host } = (req == null ? void 0 : req.headers) || {};
            const hostname = host == null ? void 0 : host.split(":")[0].toLowerCase();
            value = hostname;
            break;
          }
          default: {
            break;
          }
        }
        if (!hasItem.value && value) {
          params[getSafeParamName(key)] = value;
          return true;
        } else if (value) {
          const matcher = new RegExp(`^${hasItem.value}$`);
          const matches = Array.isArray(value) ? value.slice(-1)[0].match(matcher) : value.match(matcher);
          if (matches) {
            if (Array.isArray(matches)) {
              if (matches.groups) {
                Object.keys(matches.groups).forEach((groupKey) => {
                  params[groupKey] = matches.groups[groupKey];
                });
              } else if (hasItem.type === "host" && matches[0]) {
                params.host = matches[0];
              }
            }
            return true;
          }
        }
        return false;
      };
      const allMatch = has.every((item) => hasMatch(item)) && !missing.some((item) => hasMatch(item));
      if (allMatch) {
        return params;
      }
      return false;
    }
    function compileNonPath(value, params) {
      if (!value.includes(":")) {
        return value;
      }
      for (const key of Object.keys(params)) {
        if (value.includes(`:${key}`)) {
          value = value.replace(new RegExp(`:${key}\\*`, "g"), `:${key}--ESCAPED_PARAM_ASTERISKS`).replace(new RegExp(`:${key}\\?`, "g"), `:${key}--ESCAPED_PARAM_QUESTION`).replace(new RegExp(`:${key}\\+`, "g"), `:${key}--ESCAPED_PARAM_PLUS`).replace(new RegExp(`:${key}(?!\\w)`, "g"), `--ESCAPED_PARAM_COLON${key}`);
        }
      }
      value = value.replace(/(:|\*|\?|\+|\(|\)|\{|\})/g, "\\$1").replace(/--ESCAPED_PARAM_PLUS/g, "+").replace(/--ESCAPED_PARAM_COLON/g, ":").replace(/--ESCAPED_PARAM_QUESTION/g, "?").replace(/--ESCAPED_PARAM_ASTERISKS/g, "*");
      return (0, _pathToRegexp).compile(`/${value}`, {
        validate: false
      })(params).slice(1);
    }
    function prepareDestination(args) {
      const query = Object.assign({}, args.query);
      delete query.__nextLocale;
      delete query.__nextDefaultLocale;
      delete query.__nextDataReq;
      delete query.__nextInferredLocaleFromDefault;
      let escapedDestination = args.destination;
      for (const param of Object.keys(_extends({}, args.params, query))) {
        escapedDestination = escapeSegment(escapedDestination, param);
      }
      const parsedDestination = (0, _parseUrl).parseUrl(escapedDestination);
      const destQuery = parsedDestination.query;
      const destPath = unescapeSegments(`${parsedDestination.pathname}${parsedDestination.hash || ""}`);
      const destHostname = unescapeSegments(parsedDestination.hostname || "");
      const destPathParamKeys = [];
      const destHostnameParamKeys = [];
      (0, _pathToRegexp).pathToRegexp(destPath, destPathParamKeys);
      (0, _pathToRegexp).pathToRegexp(destHostname, destHostnameParamKeys);
      const destParams = [];
      destPathParamKeys.forEach((key) => destParams.push(key.name));
      destHostnameParamKeys.forEach((key) => destParams.push(key.name));
      const destPathCompiler = (0, _pathToRegexp).compile(
        destPath,
        // we don't validate while compiling the destination since we should
        // have already validated before we got to this point and validating
        // breaks compiling destinations with named pattern params from the source
        // e.g. /something:hello(.*) -> /another/:hello is broken with validation
        // since compile validation is meant for reversing and not for inserting
        // params from a separate path-regex into another
        {
          validate: false
        }
      );
      const destHostnameCompiler = (0, _pathToRegexp).compile(destHostname, {
        validate: false
      });
      for (const [key1, strOrArray] of Object.entries(destQuery)) {
        if (Array.isArray(strOrArray)) {
          destQuery[key1] = strOrArray.map((value) => compileNonPath(unescapeSegments(value), args.params));
        } else if (typeof strOrArray === "string") {
          destQuery[key1] = compileNonPath(unescapeSegments(strOrArray), args.params);
        }
      }
      let paramKeys = Object.keys(args.params).filter((name) => name !== "nextInternalLocale");
      if (args.appendParamsToQuery && !paramKeys.some((key) => destParams.includes(key))) {
        for (const key of paramKeys) {
          if (!(key in destQuery)) {
            destQuery[key] = args.params[key];
          }
        }
      }
      let newUrl;
      if ((0, _interceptionRoutes).isInterceptionRouteAppPath(destPath)) {
        main:
          for (const segment of destPath.split("/")) {
            for (const marker of _interceptionRoutes.INTERCEPTION_ROUTE_MARKERS) {
              if (segment.startsWith(marker)) {
                args.params["0"] = marker;
                break main;
              }
            }
            if (segment.startsWith(":")) {
              const param = segment.slice(1);
              args.params[param] = "__NEXT_EMPTY_PARAM__";
            }
          }
      }
      try {
        newUrl = destPathCompiler(args.params);
        const [pathname, hash] = newUrl.split("#");
        parsedDestination.hostname = destHostnameCompiler(args.params);
        parsedDestination.pathname = pathname;
        parsedDestination.hash = `${hash ? "#" : ""}${hash || ""}`;
        delete parsedDestination.search;
      } catch (err) {
        if (err.message.match(/Expected .*? to not repeat, but got an array/)) {
          throw new Error(`To use a multi-match in the destination you must add \`*\` at the end of the param name to signify it should repeat. https://nextjs.org/docs/messages/invalid-multi-match`);
        }
        throw err;
      }
      parsedDestination.query = _extends({}, query, parsedDestination.query);
      return {
        newUrl,
        destQuery,
        parsedDestination
      };
    }
  }
});

// ../../../../../../node_modules/next/dist/shared/lib/router/utils/parse-path.js
var require_parse_path = __commonJS({
  "../../../../../../node_modules/next/dist/shared/lib/router/utils/parse-path.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.parsePath = parsePath;
    function parsePath(path) {
      const hashIndex = path.indexOf("#");
      const queryIndex = path.indexOf("?");
      const hasQuery = queryIndex > -1 && (hashIndex < 0 || queryIndex < hashIndex);
      if (hasQuery || hashIndex > -1) {
        return {
          pathname: path.substring(0, hasQuery ? queryIndex : hashIndex),
          query: hasQuery ? path.substring(queryIndex, hashIndex > -1 ? hashIndex : void 0) : "",
          hash: hashIndex > -1 ? path.slice(hashIndex) : ""
        };
      }
      return {
        pathname: path,
        query: "",
        hash: ""
      };
    }
  }
});

// ../../../../../../node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js
var require_path_has_prefix = __commonJS({
  "../../../../../../node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.pathHasPrefix = pathHasPrefix;
    var _parsePath = require_parse_path();
    function pathHasPrefix(path, prefix) {
      if (typeof path !== "string") {
        return false;
      }
      const { pathname } = (0, _parsePath).parsePath(path);
      return pathname === prefix || pathname.startsWith(prefix + "/");
    }
  }
});

// ../../../../../../node_modules/next/dist/client/has-base-path.js
var require_has_base_path = __commonJS({
  "../../../../../../node_modules/next/dist/client/has-base-path.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.hasBasePath = hasBasePath;
    var _pathHasPrefix = require_path_has_prefix();
    var basePath = process.env.__NEXT_ROUTER_BASEPATH || "";
    function hasBasePath(path) {
      return (0, _pathHasPrefix).pathHasPrefix(path, basePath);
    }
    if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
      Object.defineProperty(exports.default, "__esModule", { value: true });
      Object.assign(exports.default, exports);
      module.exports = exports.default;
    }
  }
});

// ../../../../../../node_modules/next/dist/client/remove-base-path.js
var require_remove_base_path = __commonJS({
  "../../../../../../node_modules/next/dist/client/remove-base-path.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.removeBasePath = removeBasePath;
    var _hasBasePath = require_has_base_path();
    var basePath = process.env.__NEXT_ROUTER_BASEPATH || "";
    function removeBasePath(path) {
      if (process.env.__NEXT_MANUAL_CLIENT_BASE_PATH) {
        if (!(0, _hasBasePath).hasBasePath(path)) {
          return path;
        }
      }
      path = path.slice(basePath.length);
      if (!path.startsWith("/"))
        path = `/${path}`;
      return path;
    }
    if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
      Object.defineProperty(exports.default, "__esModule", { value: true });
      Object.assign(exports.default, exports);
      module.exports = exports.default;
    }
  }
});

// ../../../../../../node_modules/next/dist/shared/lib/router/utils/resolve-rewrites.js
var require_resolve_rewrites = __commonJS({
  "../../../../../../node_modules/next/dist/shared/lib/router/utils/resolve-rewrites.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = resolveRewrites;
    var _pathMatch = require_path_match();
    var _prepareDestination = require_prepare_destination();
    var _removeTrailingSlash = require_remove_trailing_slash();
    var _normalizeLocalePath = require_normalize_locale_path();
    var _removeBasePath = require_remove_base_path();
    var _parseRelativeUrl = require_parse_relative_url();
    function resolveRewrites(asPath, pages, rewrites, query, resolveHref, locales) {
      let matchedPage = false;
      let externalDest = false;
      let parsedAs = (0, _parseRelativeUrl).parseRelativeUrl(asPath);
      let fsPathname = (0, _removeTrailingSlash).removeTrailingSlash((0, _normalizeLocalePath).normalizeLocalePath((0, _removeBasePath).removeBasePath(parsedAs.pathname), locales).pathname);
      let resolvedHref;
      const handleRewrite = (rewrite) => {
        const matcher = (0, _pathMatch).getPathMatch(rewrite.source + (process.env.__NEXT_TRAILING_SLASH ? "(/)?" : ""), {
          removeUnnamedParams: true,
          strict: true
        });
        let params = matcher(parsedAs.pathname);
        if ((rewrite.has || rewrite.missing) && params) {
          const hasParams = (0, _prepareDestination).matchHas({
            headers: {
              host: document.location.hostname
            },
            cookies: document.cookie.split("; ").reduce((acc, item) => {
              const [key, ...value] = item.split("=");
              acc[key] = value.join("=");
              return acc;
            }, {})
          }, parsedAs.query, rewrite.has, rewrite.missing);
          if (hasParams) {
            Object.assign(params, hasParams);
          } else {
            params = false;
          }
        }
        if (params) {
          if (!rewrite.destination) {
            externalDest = true;
            return true;
          }
          const destRes = (0, _prepareDestination).prepareDestination({
            appendParamsToQuery: true,
            destination: rewrite.destination,
            params,
            query
          });
          parsedAs = destRes.parsedDestination;
          asPath = destRes.newUrl;
          Object.assign(query, destRes.parsedDestination.query);
          fsPathname = (0, _removeTrailingSlash).removeTrailingSlash((0, _normalizeLocalePath).normalizeLocalePath((0, _removeBasePath).removeBasePath(asPath), locales).pathname);
          if (pages.includes(fsPathname)) {
            matchedPage = true;
            resolvedHref = fsPathname;
            return true;
          }
          resolvedHref = resolveHref(fsPathname);
          if (resolvedHref !== asPath && pages.includes(resolvedHref)) {
            matchedPage = true;
            return true;
          }
        }
      };
      let finished = false;
      for (let i = 0; i < rewrites.beforeFiles.length; i++) {
        handleRewrite(rewrites.beforeFiles[i]);
      }
      matchedPage = pages.includes(fsPathname);
      if (!matchedPage) {
        if (!finished) {
          for (let i = 0; i < rewrites.afterFiles.length; i++) {
            if (handleRewrite(rewrites.afterFiles[i])) {
              finished = true;
              break;
            }
          }
        }
        if (!finished) {
          resolvedHref = resolveHref(fsPathname);
          matchedPage = pages.includes(resolvedHref);
          finished = matchedPage;
        }
        if (!finished) {
          for (let i = 0; i < rewrites.fallback.length; i++) {
            if (handleRewrite(rewrites.fallback[i])) {
              finished = true;
              break;
            }
          }
        }
      }
      return {
        asPath,
        parsedAs,
        matchedPage,
        resolvedHref,
        externalDest
      };
    }
  }
});

// ../../../../../../node_modules/next/dist/shared/lib/router/utils/route-matcher.js
var require_route_matcher = __commonJS({
  "../../../../../../node_modules/next/dist/shared/lib/router/utils/route-matcher.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getRouteMatcher = getRouteMatcher;
    var _utils = require_utils2();
    function getRouteMatcher({ re, groups }) {
      return (pathname) => {
        const routeMatch = re.exec(pathname);
        if (!routeMatch) {
          return false;
        }
        const decode = (param) => {
          try {
            return decodeURIComponent(param);
          } catch (_) {
            throw new _utils.DecodeError("failed to decode param");
          }
        };
        const params = {};
        Object.keys(groups).forEach((slugName) => {
          const g = groups[slugName];
          const m = routeMatch[g.pos];
          if (m !== void 0) {
            params[slugName] = ~m.indexOf("/") ? m.split("/").map((entry) => decode(entry)) : g.repeat ? [
              decode(m)
            ] : decode(m);
          }
        });
        return params;
      };
    }
  }
});

// ../../../../../../node_modules/next/dist/shared/lib/router/utils/route-regex.js
var require_route_regex = __commonJS({
  "../../../../../../node_modules/next/dist/shared/lib/router/utils/route-regex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getRouteRegex = getRouteRegex;
    exports.getNamedRouteRegex = getNamedRouteRegex;
    exports.getNamedMiddlewareRegex = getNamedMiddlewareRegex;
    var _extends = require_extends().default;
    var _escapeRegexp = require_escape_regexp();
    var _removeTrailingSlash = require_remove_trailing_slash();
    var NEXT_QUERY_PARAM_PREFIX = "nextParam";
    function parseParameter(param) {
      const optional = param.startsWith("[") && param.endsWith("]");
      if (optional) {
        param = param.slice(1, -1);
      }
      const repeat = param.startsWith("...");
      if (repeat) {
        param = param.slice(3);
      }
      return {
        key: param,
        repeat,
        optional
      };
    }
    function getParametrizedRoute(route) {
      const segments = (0, _removeTrailingSlash).removeTrailingSlash(route).slice(1).split("/");
      const groups = {};
      let groupIndex = 1;
      return {
        parameterizedRoute: segments.map((segment) => {
          if (segment.startsWith("[") && segment.endsWith("]")) {
            const { key, optional, repeat } = parseParameter(segment.slice(1, -1));
            groups[key] = {
              pos: groupIndex++,
              repeat,
              optional
            };
            return repeat ? optional ? "(?:/(.+?))?" : "/(.+?)" : "/([^/]+?)";
          } else {
            return `/${(0, _escapeRegexp).escapeStringRegexp(segment)}`;
          }
        }).join(""),
        groups
      };
    }
    function getRouteRegex(normalizedRoute) {
      const { parameterizedRoute, groups } = getParametrizedRoute(normalizedRoute);
      return {
        re: new RegExp(`^${parameterizedRoute}(?:/)?$`),
        groups
      };
    }
    function buildGetSafeRouteKey() {
      let routeKeyCharCode = 97;
      let routeKeyCharLength = 1;
      return () => {
        let routeKey = "";
        for (let i = 0; i < routeKeyCharLength; i++) {
          routeKey += String.fromCharCode(routeKeyCharCode);
          routeKeyCharCode++;
          if (routeKeyCharCode > 122) {
            routeKeyCharLength++;
            routeKeyCharCode = 97;
          }
        }
        return routeKey;
      };
    }
    function getNamedParametrizedRoute(route, prefixRouteKeys) {
      const segments = (0, _removeTrailingSlash).removeTrailingSlash(route).slice(1).split("/");
      const getSafeRouteKey = buildGetSafeRouteKey();
      const routeKeys = {};
      return {
        namedParameterizedRoute: segments.map((segment) => {
          if (segment.startsWith("[") && segment.endsWith("]")) {
            const { key, optional, repeat } = parseParameter(segment.slice(1, -1));
            let cleanedKey = key.replace(/\W/g, "");
            let invalidKey = false;
            if (cleanedKey.length === 0 || cleanedKey.length > 30) {
              invalidKey = true;
            }
            if (!isNaN(parseInt(cleanedKey.slice(0, 1)))) {
              invalidKey = true;
            }
            if (invalidKey) {
              cleanedKey = getSafeRouteKey();
            }
            if (prefixRouteKeys) {
              cleanedKey = `${NEXT_QUERY_PARAM_PREFIX}${cleanedKey}`;
              routeKeys[cleanedKey] = `${NEXT_QUERY_PARAM_PREFIX}${key}`;
            } else {
              routeKeys[cleanedKey] = `${key}`;
            }
            return repeat ? optional ? `(?:/(?<${cleanedKey}>.+?))?` : `/(?<${cleanedKey}>.+?)` : `/(?<${cleanedKey}>[^/]+?)`;
          } else {
            return `/${(0, _escapeRegexp).escapeStringRegexp(segment)}`;
          }
        }).join(""),
        routeKeys
      };
    }
    function getNamedRouteRegex(normalizedRoute, prefixRouteKey) {
      const result = getNamedParametrizedRoute(normalizedRoute, prefixRouteKey);
      return _extends({}, getRouteRegex(normalizedRoute), {
        namedRegex: `^${result.namedParameterizedRoute}(?:/)?$`,
        routeKeys: result.routeKeys
      });
    }
    function getNamedMiddlewareRegex(normalizedRoute, options) {
      const { parameterizedRoute } = getParametrizedRoute(normalizedRoute);
      const { catchAll = true } = options;
      if (parameterizedRoute === "/") {
        let catchAllRegex = catchAll ? ".*" : "";
        return {
          namedRegex: `^/${catchAllRegex}$`
        };
      }
      const { namedParameterizedRoute } = getNamedParametrizedRoute(normalizedRoute, false);
      let catchAllGroupedRegex = catchAll ? "(?:(/.*)?)" : "";
      return {
        namedRegex: `^${namedParameterizedRoute}${catchAllGroupedRegex}$`
      };
    }
  }
});

// ../../../../../../node_modules/next/dist/shared/lib/router/utils/format-url.js
var require_format_url = __commonJS({
  "../../../../../../node_modules/next/dist/shared/lib/router/utils/format-url.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.formatUrl = formatUrl;
    exports.formatWithValidation = formatWithValidation;
    exports.urlObjectKeys = void 0;
    var _interop_require_wildcard = require_interop_require_wildcard().default;
    var querystring = _interop_require_wildcard(require_querystring());
    var slashedProtocols = /https?|ftp|gopher|file/;
    function formatUrl(urlObj) {
      let { auth, hostname } = urlObj;
      let protocol = urlObj.protocol || "";
      let pathname = urlObj.pathname || "";
      let hash = urlObj.hash || "";
      let query = urlObj.query || "";
      let host = false;
      auth = auth ? encodeURIComponent(auth).replace(/%3A/i, ":") + "@" : "";
      if (urlObj.host) {
        host = auth + urlObj.host;
      } else if (hostname) {
        host = auth + (~hostname.indexOf(":") ? `[${hostname}]` : hostname);
        if (urlObj.port) {
          host += ":" + urlObj.port;
        }
      }
      if (query && typeof query === "object") {
        query = String(querystring.urlQueryToSearchParams(query));
      }
      let search = urlObj.search || query && `?${query}` || "";
      if (protocol && !protocol.endsWith(":"))
        protocol += ":";
      if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host !== false) {
        host = "//" + (host || "");
        if (pathname && pathname[0] !== "/")
          pathname = "/" + pathname;
      } else if (!host) {
        host = "";
      }
      if (hash && hash[0] !== "#")
        hash = "#" + hash;
      if (search && search[0] !== "?")
        search = "?" + search;
      pathname = pathname.replace(/[?#]/g, encodeURIComponent);
      search = search.replace("#", "%23");
      return `${protocol}${host}${pathname}${search}${hash}`;
    }
    var urlObjectKeys = [
      "auth",
      "hash",
      "host",
      "hostname",
      "href",
      "path",
      "pathname",
      "port",
      "protocol",
      "query",
      "search",
      "slashes"
    ];
    exports.urlObjectKeys = urlObjectKeys;
    function formatWithValidation(url) {
      if (true) {
        if (url !== null && typeof url === "object") {
          Object.keys(url).forEach((key) => {
            if (urlObjectKeys.indexOf(key) === -1) {
              console.warn(`Unknown key passed via urlObject into url.format: ${key}`);
            }
          });
        }
      }
      return formatUrl(url);
    }
  }
});

// ../../../../../../node_modules/next/dist/shared/lib/i18n/detect-domain-locale.js
var require_detect_domain_locale = __commonJS({
  "../../../../../../node_modules/next/dist/shared/lib/i18n/detect-domain-locale.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.detectDomainLocale = detectDomainLocale;
    function detectDomainLocale(domainItems, hostname, detectedLocale) {
      if (!domainItems)
        return;
      if (detectedLocale) {
        detectedLocale = detectedLocale.toLowerCase();
      }
      for (const item of domainItems) {
        var ref, ref1;
        const domainHostname = (ref = item.domain) == null ? void 0 : ref.split(":")[0].toLowerCase();
        if (hostname === domainHostname || detectedLocale === item.defaultLocale.toLowerCase() || ((ref1 = item.locales) == null ? void 0 : ref1.some((locale) => locale.toLowerCase() === detectedLocale))) {
          return item;
        }
      }
    }
  }
});

// ../../../../../../node_modules/next/dist/client/detect-domain-locale.js
var require_detect_domain_locale2 = __commonJS({
  "../../../../../../node_modules/next/dist/client/detect-domain-locale.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.detectDomainLocale = void 0;
    var detectDomainLocale = (...args) => {
      if (process.env.__NEXT_I18N_SUPPORT) {
        return require_detect_domain_locale().detectDomainLocale(...args);
      }
    };
    exports.detectDomainLocale = detectDomainLocale;
    if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
      Object.defineProperty(exports.default, "__esModule", { value: true });
      Object.assign(exports.default, exports);
      module.exports = exports.default;
    }
  }
});

// ../../../../../../node_modules/next/dist/client/normalize-trailing-slash.js
var require_normalize_trailing_slash = __commonJS({
  "../../../../../../node_modules/next/dist/client/normalize-trailing-slash.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.normalizePathTrailingSlash = void 0;
    var _removeTrailingSlash = require_remove_trailing_slash();
    var _parsePath = require_parse_path();
    var normalizePathTrailingSlash = (path) => {
      if (!path.startsWith("/") || process.env.__NEXT_MANUAL_TRAILING_SLASH) {
        return path;
      }
      const { pathname, query, hash } = (0, _parsePath).parsePath(path);
      if (process.env.__NEXT_TRAILING_SLASH) {
        if (/\.[^/]+\/?$/.test(pathname)) {
          return `${(0, _removeTrailingSlash).removeTrailingSlash(pathname)}${query}${hash}`;
        } else if (pathname.endsWith("/")) {
          return `${pathname}${query}${hash}`;
        } else {
          return `${pathname}/${query}${hash}`;
        }
      }
      return `${(0, _removeTrailingSlash).removeTrailingSlash(pathname)}${query}${hash}`;
    };
    exports.normalizePathTrailingSlash = normalizePathTrailingSlash;
    if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
      Object.defineProperty(exports.default, "__esModule", { value: true });
      Object.assign(exports.default, exports);
      module.exports = exports.default;
    }
  }
});

// ../../../../../../node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js
var require_add_path_prefix = __commonJS({
  "../../../../../../node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.addPathPrefix = addPathPrefix;
    var _parsePath = require_parse_path();
    function addPathPrefix(path, prefix) {
      if (!path.startsWith("/") || !prefix) {
        return path;
      }
      const { pathname, query, hash } = (0, _parsePath).parsePath(path);
      return `${prefix}${pathname}${query}${hash}`;
    }
  }
});

// ../../../../../../node_modules/next/dist/shared/lib/router/utils/add-locale.js
var require_add_locale = __commonJS({
  "../../../../../../node_modules/next/dist/shared/lib/router/utils/add-locale.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.addLocale = addLocale;
    var _addPathPrefix = require_add_path_prefix();
    var _pathHasPrefix = require_path_has_prefix();
    function addLocale(path, locale, defaultLocale, ignorePrefix) {
      if (!locale || locale === defaultLocale)
        return path;
      const lower = path.toLowerCase();
      if (!ignorePrefix) {
        if ((0, _pathHasPrefix).pathHasPrefix(lower, "/api"))
          return path;
        if ((0, _pathHasPrefix).pathHasPrefix(lower, `/${locale.toLowerCase()}`))
          return path;
      }
      return (0, _addPathPrefix).addPathPrefix(path, `/${locale}`);
    }
  }
});

// ../../../../../../node_modules/next/dist/client/add-locale.js
var require_add_locale2 = __commonJS({
  "../../../../../../node_modules/next/dist/client/add-locale.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.addLocale = void 0;
    var _normalizeTrailingSlash = require_normalize_trailing_slash();
    var addLocale = (path, ...args) => {
      if (process.env.__NEXT_I18N_SUPPORT) {
        return (0, _normalizeTrailingSlash).normalizePathTrailingSlash(require_add_locale().addLocale(path, ...args));
      }
      return path;
    };
    exports.addLocale = addLocale;
    if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
      Object.defineProperty(exports.default, "__esModule", { value: true });
      Object.assign(exports.default, exports);
      module.exports = exports.default;
    }
  }
});

// ../../../../../../node_modules/next/dist/client/remove-locale.js
var require_remove_locale = __commonJS({
  "../../../../../../node_modules/next/dist/client/remove-locale.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.removeLocale = removeLocale;
    var _parsePath = require_parse_path();
    function removeLocale(path, locale) {
      if (process.env.__NEXT_I18N_SUPPORT) {
        const { pathname } = (0, _parsePath).parsePath(path);
        const pathLower = pathname.toLowerCase();
        const localeLower = locale == null ? void 0 : locale.toLowerCase();
        return locale && (pathLower.startsWith(`/${localeLower}/`) || pathLower === `/${localeLower}`) ? `${pathname.length === locale.length + 1 ? `/` : ``}${path.slice(locale.length + 1)}` : path;
      }
      return path;
    }
    if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
      Object.defineProperty(exports.default, "__esModule", { value: true });
      Object.assign(exports.default, exports);
      module.exports = exports.default;
    }
  }
});

// ../../../../../../node_modules/next/dist/client/add-base-path.js
var require_add_base_path = __commonJS({
  "../../../../../../node_modules/next/dist/client/add-base-path.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.addBasePath = addBasePath;
    var _addPathPrefix = require_add_path_prefix();
    var _normalizeTrailingSlash = require_normalize_trailing_slash();
    var basePath = process.env.__NEXT_ROUTER_BASEPATH || "";
    function addBasePath(path, required) {
      if (process.env.__NEXT_MANUAL_CLIENT_BASE_PATH) {
        if (!required) {
          return path;
        }
      }
      return (0, _normalizeTrailingSlash).normalizePathTrailingSlash((0, _addPathPrefix).addPathPrefix(path, basePath));
    }
    if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
      Object.defineProperty(exports.default, "__esModule", { value: true });
      Object.assign(exports.default, exports);
      module.exports = exports.default;
    }
  }
});

// ../../../../../../node_modules/next/dist/lib/is-api-route.js
var require_is_api_route = __commonJS({
  "../../../../../../node_modules/next/dist/lib/is-api-route.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isAPIRoute = isAPIRoute;
    function isAPIRoute(value) {
      return value === "/api" || Boolean(value == null ? void 0 : value.startsWith("/api/"));
    }
  }
});

// ../../../../../../node_modules/next/dist/shared/lib/router/utils/remove-path-prefix.js
var require_remove_path_prefix = __commonJS({
  "../../../../../../node_modules/next/dist/shared/lib/router/utils/remove-path-prefix.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.removePathPrefix = removePathPrefix;
    var _pathHasPrefix = require_path_has_prefix();
    function removePathPrefix(path, prefix) {
      if (!(0, _pathHasPrefix).pathHasPrefix(path, prefix)) {
        return path;
      }
      const withoutPrefix = path.slice(prefix.length);
      if (withoutPrefix.startsWith("/")) {
        return withoutPrefix;
      }
      return `/${withoutPrefix}`;
    }
  }
});

// ../../../../../../node_modules/next/dist/shared/lib/router/utils/get-next-pathname-info.js
var require_get_next_pathname_info = __commonJS({
  "../../../../../../node_modules/next/dist/shared/lib/router/utils/get-next-pathname-info.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getNextPathnameInfo = getNextPathnameInfo;
    var _normalizeLocalePath = require_normalize_locale_path();
    var _removePathPrefix = require_remove_path_prefix();
    var _pathHasPrefix = require_path_has_prefix();
    function getNextPathnameInfo(pathname, options) {
      var _nextConfig;
      const { basePath, i18n, trailingSlash } = (_nextConfig = options.nextConfig) != null ? _nextConfig : {};
      const info = {
        pathname,
        trailingSlash: pathname !== "/" ? pathname.endsWith("/") : trailingSlash
      };
      if (basePath && (0, _pathHasPrefix).pathHasPrefix(info.pathname, basePath)) {
        info.pathname = (0, _removePathPrefix).removePathPrefix(info.pathname, basePath);
        info.basePath = basePath;
      }
      if (options.parseData === true && info.pathname.startsWith("/_next/data/") && info.pathname.endsWith(".json")) {
        const paths = info.pathname.replace(/^\/_next\/data\//, "").replace(/\.json$/, "").split("/");
        const buildId = paths[0];
        info.pathname = paths[1] !== "index" ? `/${paths.slice(1).join("/")}` : "/";
        info.buildId = buildId;
      }
      if (options.i18nProvider) {
        const result = options.i18nProvider.analyze(info.pathname);
        info.locale = result.detectedLocale;
        var _pathname;
        info.pathname = (_pathname = result.pathname) != null ? _pathname : info.pathname;
      } else if (i18n) {
        const pathLocale = (0, _normalizeLocalePath).normalizeLocalePath(info.pathname, i18n.locales);
        info.locale = pathLocale.detectedLocale;
        var _pathname1;
        info.pathname = (_pathname1 = pathLocale.pathname) != null ? _pathname1 : info.pathname;
      }
      return info;
    }
  }
});

// ../../../../../../node_modules/next/dist/shared/lib/router/utils/add-path-suffix.js
var require_add_path_suffix = __commonJS({
  "../../../../../../node_modules/next/dist/shared/lib/router/utils/add-path-suffix.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.addPathSuffix = addPathSuffix;
    var _parsePath = require_parse_path();
    function addPathSuffix(path, suffix) {
      if (!path.startsWith("/") || !suffix) {
        return path;
      }
      const { pathname, query, hash } = (0, _parsePath).parsePath(path);
      return `${pathname}${suffix}${query}${hash}`;
    }
  }
});

// ../../../../../../node_modules/next/dist/shared/lib/router/utils/format-next-pathname-info.js
var require_format_next_pathname_info = __commonJS({
  "../../../../../../node_modules/next/dist/shared/lib/router/utils/format-next-pathname-info.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.formatNextPathnameInfo = formatNextPathnameInfo;
    var _removeTrailingSlash = require_remove_trailing_slash();
    var _addPathPrefix = require_add_path_prefix();
    var _addPathSuffix = require_add_path_suffix();
    var _addLocale = require_add_locale();
    function formatNextPathnameInfo(info) {
      let pathname = (0, _addLocale).addLocale(info.pathname, info.locale, info.buildId ? void 0 : info.defaultLocale, info.ignorePrefix);
      if (info.buildId || !info.trailingSlash) {
        pathname = (0, _removeTrailingSlash).removeTrailingSlash(pathname);
      }
      if (info.buildId) {
        pathname = (0, _addPathSuffix).addPathSuffix((0, _addPathPrefix).addPathPrefix(pathname, `/_next/data/${info.buildId}`), info.pathname === "/" ? "index.json" : ".json");
      }
      pathname = (0, _addPathPrefix).addPathPrefix(pathname, info.basePath);
      return !info.buildId && info.trailingSlash ? !pathname.endsWith("/") ? (0, _addPathSuffix).addPathSuffix(pathname, "/") : pathname : (0, _removeTrailingSlash).removeTrailingSlash(pathname);
    }
  }
});

// ../../../../../../node_modules/next/dist/shared/lib/router/utils/compare-states.js
var require_compare_states = __commonJS({
  "../../../../../../node_modules/next/dist/shared/lib/router/utils/compare-states.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.compareRouterStates = compareRouterStates;
    function compareRouterStates(a, b) {
      const stateKeys = Object.keys(a);
      if (stateKeys.length !== Object.keys(b).length)
        return false;
      for (let i = stateKeys.length; i--; ) {
        const key = stateKeys[i];
        if (key === "query") {
          const queryKeys = Object.keys(a.query);
          if (queryKeys.length !== Object.keys(b.query).length) {
            return false;
          }
          for (let j = queryKeys.length; j--; ) {
            const queryKey = queryKeys[j];
            if (!b.query.hasOwnProperty(queryKey) || a.query[queryKey] !== b.query[queryKey]) {
              return false;
            }
          }
        } else if (!b.hasOwnProperty(key) || a[key] !== b[key]) {
          return false;
        }
      }
      return true;
    }
  }
});

// ../../../../../../node_modules/next/dist/shared/lib/router/utils/is-local-url.js
var require_is_local_url = __commonJS({
  "../../../../../../node_modules/next/dist/shared/lib/router/utils/is-local-url.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isLocalURL = isLocalURL;
    var _utils = require_utils2();
    var _hasBasePath = require_has_base_path();
    function isLocalURL(url) {
      if (!(0, _utils).isAbsoluteUrl(url))
        return true;
      try {
        const locationOrigin = (0, _utils).getLocationOrigin();
        const resolved = new URL(url, locationOrigin);
        return resolved.origin === locationOrigin && (0, _hasBasePath).hasBasePath(resolved.pathname);
      } catch (_) {
        return false;
      }
    }
  }
});

// ../../../../../../node_modules/next/dist/shared/lib/router/utils/is-bot.js
var require_is_bot = __commonJS({
  "../../../../../../node_modules/next/dist/shared/lib/router/utils/is-bot.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isBot = isBot;
    function isBot(userAgent) {
      return /Googlebot|Mediapartners-Google|AdsBot-Google|googleweblight|Storebot-Google|Google-PageRenderer|Bingbot|BingPreview|Slurp|DuckDuckBot|baiduspider|yandex|sogou|LinkedInBot|bitlybot|tumblr|vkShare|quora link preview|facebookexternalhit|facebookcatalog|Twitterbot|applebot|redditbot|Slackbot|Discordbot|WhatsApp|SkypeUriPreview|ia_archiver/i.test(userAgent);
    }
  }
});

// ../../../../../../node_modules/next/dist/shared/lib/router/utils/omit.js
var require_omit = __commonJS({
  "../../../../../../node_modules/next/dist/shared/lib/router/utils/omit.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.omit = omit;
    function omit(object, keys) {
      const omitted = {};
      Object.keys(object).forEach((key) => {
        if (!keys.includes(key)) {
          omitted[key] = object[key];
        }
      });
      return omitted;
    }
  }
});

// ../../../../../../node_modules/next/dist/shared/lib/router/utils/interpolate-as.js
var require_interpolate_as = __commonJS({
  "../../../../../../node_modules/next/dist/shared/lib/router/utils/interpolate-as.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.interpolateAs = interpolateAs;
    var _routeMatcher = require_route_matcher();
    var _routeRegex = require_route_regex();
    function interpolateAs(route, asPathname, query) {
      let interpolatedRoute = "";
      const dynamicRegex = (0, _routeRegex).getRouteRegex(route);
      const dynamicGroups = dynamicRegex.groups;
      const dynamicMatches = (
        // Try to match the dynamic route against the asPath
        (asPathname !== route ? (0, _routeMatcher).getRouteMatcher(dynamicRegex)(asPathname) : "") || // Fall back to reading the values from the href
        // TODO: should this take priority; also need to change in the router.
        query
      );
      interpolatedRoute = route;
      const params = Object.keys(dynamicGroups);
      if (!params.every((param) => {
        let value = dynamicMatches[param] || "";
        const { repeat, optional } = dynamicGroups[param];
        let replaced = `[${repeat ? "..." : ""}${param}]`;
        if (optional) {
          replaced = `${!value ? "/" : ""}[${replaced}]`;
        }
        if (repeat && !Array.isArray(value))
          value = [
            value
          ];
        return (optional || param in dynamicMatches) && // Interpolate group into data URL if present
        (interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map(
          // these values should be fully encoded instead of just
          // path delimiter escaped since they are being inserted
          // into the URL and we expect URL encoded segments
          // when parsing dynamic route params
          (segment) => encodeURIComponent(segment)
        ).join("/") : encodeURIComponent(value)) || "/");
      })) {
        interpolatedRoute = "";
      }
      return {
        params,
        result: interpolatedRoute
      };
    }
  }
});

// ../../../../../../node_modules/next/dist/shared/lib/router/utils/resolve-href.js
var require_resolve_href = __commonJS({
  "../../../../../../node_modules/next/dist/shared/lib/router/utils/resolve-href.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.resolveHref = resolveHref;
    var _querystring = require_querystring();
    var _formatUrl = require_format_url();
    var _omit = require_omit();
    var _utils = require_utils2();
    var _normalizeTrailingSlash = require_normalize_trailing_slash();
    var _isLocalUrl = require_is_local_url();
    var _isDynamic = require_is_dynamic();
    var _interpolateAs = require_interpolate_as();
    function resolveHref(router, href, resolveAs) {
      let base;
      let urlAsString = typeof href === "string" ? href : (0, _formatUrl).formatWithValidation(href);
      const urlProtoMatch = urlAsString.match(/^[a-zA-Z]{1,}:\/\//);
      const urlAsStringNoProto = urlProtoMatch ? urlAsString.slice(urlProtoMatch[0].length) : urlAsString;
      const urlParts = urlAsStringNoProto.split("?");
      if ((urlParts[0] || "").match(/(\/\/|\\)/)) {
        console.error(`Invalid href '${urlAsString}' passed to next/router in page: '${router.pathname}'. Repeated forward-slashes (//) or backslashes \\ are not valid in the href.`);
        const normalizedUrl = (0, _utils).normalizeRepeatedSlashes(urlAsStringNoProto);
        urlAsString = (urlProtoMatch ? urlProtoMatch[0] : "") + normalizedUrl;
      }
      if (!(0, _isLocalUrl).isLocalURL(urlAsString)) {
        return resolveAs ? [
          urlAsString
        ] : urlAsString;
      }
      try {
        base = new URL(urlAsString.startsWith("#") ? router.asPath : router.pathname, "http://n");
      } catch (_) {
        base = new URL("/", "http://n");
      }
      try {
        const finalUrl = new URL(urlAsString, base);
        finalUrl.pathname = (0, _normalizeTrailingSlash).normalizePathTrailingSlash(finalUrl.pathname);
        let interpolatedAs = "";
        if ((0, _isDynamic).isDynamicRoute(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {
          const query = (0, _querystring).searchParamsToUrlQuery(finalUrl.searchParams);
          const { result, params } = (0, _interpolateAs).interpolateAs(finalUrl.pathname, finalUrl.pathname, query);
          if (result) {
            interpolatedAs = (0, _formatUrl).formatWithValidation({
              pathname: result,
              hash: finalUrl.hash,
              query: (0, _omit).omit(query, params)
            });
          }
        }
        const resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;
        return resolveAs ? [
          resolvedHref,
          interpolatedAs || resolvedHref
        ] : resolvedHref;
      } catch (_1) {
        return resolveAs ? [
          urlAsString
        ] : urlAsString;
      }
    }
  }
});

// ../../../../../../node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js
var require_handle_smooth_scroll = __commonJS({
  "../../../../../../node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.handleSmoothScroll = handleSmoothScroll;
    function handleSmoothScroll(fn, options = {}) {
      const htmlElement = document.documentElement;
      const existing = htmlElement.style.scrollBehavior;
      htmlElement.style.scrollBehavior = "auto";
      if (!options.dontForceLayout) {
        htmlElement.getClientRects();
      }
      fn();
      htmlElement.style.scrollBehavior = existing;
    }
  }
});

// ../../../../../../node_modules/next/dist/compiled/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "../../../../../../node_modules/next/dist/compiled/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_SERVER_CONTEXT_TYPE = Symbol.for("react.server_context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var REACT_MODULE_REFERENCE;
        {
          REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
        }
        function isValidElementType(type) {
          if (typeof type === "string" || typeof type === "function") {
            return true;
          }
          if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
            return true;
          }
          if (typeof type === "object" && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
            // types supported by any Flight configuration anywhere since
            // we don't know which Flight build this will end up being used
            // with.
            type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
              return true;
            }
          }
          return false;
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                  case REACT_SUSPENSE_LIST_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_SERVER_CONTEXT_TYPE:
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var SuspenseList = REACT_SUSPENSE_LIST_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        var hasWarnedAboutDeprecatedIsConcurrentMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.");
            }
          }
          return false;
        }
        function isConcurrentMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
              hasWarnedAboutDeprecatedIsConcurrentMode = true;
              console["warn"]("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.");
            }
          }
          return false;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        function isSuspenseList(object) {
          return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
        }
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.SuspenseList = SuspenseList;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isSuspenseList = isSuspenseList;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// ../../../../../../node_modules/next/dist/compiled/react-is/index.js
var require_react_is = __commonJS({
  "../../../../../../node_modules/next/dist/compiled/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// ../../../../../../node_modules/next/dist/shared/lib/fnv1a.js
var require_fnv1a = __commonJS({
  "../../../../../../node_modules/next/dist/shared/lib/fnv1a.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = fnv1a;
    function fnv1a(inputString, { size = 32, seed = 0 } = {}) {
      if (!FNV_PRIMES[size]) {
        throw new Error("The `size` option must be one of 32, 64, 128, 256, 512, or 1024");
      }
      let hash = FNV_OFFSETS[size] ^ BigInt(seed);
      const fnvPrime = FNV_PRIMES[size];
      let isUnicoded = false;
      for (let index = 0; index < inputString.length; index++) {
        let characterCode = inputString.charCodeAt(index);
        if (characterCode > 127 && !isUnicoded) {
          inputString = unescape(encodeURIComponent(inputString));
          characterCode = inputString.charCodeAt(index);
          isUnicoded = true;
        }
        hash ^= BigInt(characterCode);
        hash = BigInt.asUintN(size, hash * fnvPrime);
      }
      return hash;
    }
    var FNV_PRIMES = {
      32: BigInt(16777619),
      64: BigInt(1099511628211),
      128: BigInt(3094850098213451e11),
      256: BigInt(37414441915671115e34),
      512: BigInt(3583591587484487e88),
      1024: BigInt(5016456510113119e189)
    };
    var FNV_OFFSETS = {
      32: BigInt(2166136261),
      64: BigInt(14695981039346655e3),
      128: BigInt(14406626329776981e22),
      256: BigInt(10002925795805258e61),
      512: BigInt(965930312949667e139),
      1024: BigInt(1419779506494762e271)
    };
  }
});

// ../../../../../../node_modules/next/dist/shared/lib/bloom-filter/utils.js
var require_utils3 = __commonJS({
  "../../../../../../node_modules/next/dist/shared/lib/bloom-filter/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.numberToHex = numberToHex;
    exports.randomInt = randomInt;
    exports.getDefaultSeed = getDefaultSeed;
    function numberToHex(elem) {
      let e = Number(elem).toString(16);
      if (e.length % 4 !== 0) {
        e = "0".repeat(4 - e.length % 4) + e;
      }
      return e;
    }
    function randomInt(min, max, random) {
      if (random === void 0) {
        random = Math.random;
      }
      min = Math.ceil(min);
      max = Math.floor(max);
      const rn = random();
      return Math.floor(rn * (max - min + 1)) + min;
    }
    function getDefaultSeed() {
      return 78187493520;
    }
  }
});

// ../../../../../../node_modules/next/dist/shared/lib/bloom-filter/hashing.js
var require_hashing = __commonJS({
  "../../../../../../node_modules/next/dist/shared/lib/bloom-filter/hashing.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _interop_require_default = require_interop_require_default().default;
    var _fnv1A = _interop_require_default(require_fnv1a());
    var _utils = require_utils3();
    var Hashing = class {
      /**
      * Apply enhanced Double Hashing to produce a n-hash
      * @see {@link http://peterd.org/pcd-diss.pdf} s6.5.4
      * @param  n - The indice of the hash function we want to produce
      * @param  hashA - The result of the first hash function applied to a value.
      * @param  hashB - The result of the second hash function applied to a value.
      * @param  size - The size of the datastructures associated to the hash context (ex: the size of a Bloom Filter)
      * @return The result of hash_n applied to a value.
      * @memberof Hashing
      * @author Thomas Minier
      * @author Arnaud Grall
      */
      doubleHashing(n, hashA, hashB, size) {
        return Math.abs((hashA + n * hashB + Math.floor((n ** 3 - n) / 6)) % size);
      }
      /**
      * Generate a set of distinct indexes on interval [0, size) using the double hashing technique
      * For generating efficiently distinct indexes we re-hash after detecting a cycle by changing slightly the seed.
      * It has the effect of generating faster distinct indexes without loosing entirely the utility of the double hashing.
      * For small number of indexes it will work perfectly. For a number close to the size, and size very large
      * Advise: do not generate `size` indexes for a large interval. In practice, size should be equal
      * to the number of hash functions used and is often low.
      *
      * @param  element  - The element to hash
      * @param  size     - the range on which we can generate an index [0, size) = size
      * @param  number   - The number of indexes desired
      * @param  seed     - The seed used
      * @return Array<number>
      * @author Arnaud Grall
      * @author Simon Woolf (SimonWoolf)
      */
      getDistinctIndexes(element, size, number, seed) {
        if (seed === void 0) {
          seed = (0, _utils).getDefaultSeed();
        }
        let n = 0;
        const indexes = /* @__PURE__ */ new Set();
        let hashes = this.hashTwice(element, seed);
        while (indexes.size < number) {
          const ind = hashes.first % size;
          if (!indexes.has(ind)) {
            indexes.add(ind);
          }
          hashes.first = (hashes.first + hashes.second) % size;
          hashes.second = (hashes.second + n) % size;
          n++;
          if (n > size) {
            seed++;
            hashes = this.hashTwice(element, seed);
          }
        }
        return [
          ...indexes.values()
        ];
      }
      /**
      * Generate N indexes on range [0, size)
      * It uses the double hashing technique to generate the indexes.
      * It hash twice the value only once before generating the indexes.
      * Warning: you can have a lot of modulo collisions.
      * @param  element    - The element to hash
      * @param  size       - The range on which we can generate the index, exclusive
      * @param  hashCount  - The number of indexes we want
      * @return An array of indexes on range [0, size)
      */
      getIndexes(element, size, hashCount, seed) {
        if (seed === void 0) {
          seed = (0, _utils).getDefaultSeed();
        }
        const arr = [];
        const hashes = this.hashTwice(element, seed);
        for (let i = 0; i < hashCount; i++) {
          arr.push(this.doubleHashing(i, hashes.first, hashes.second, size));
        }
        return arr;
      }
      /**
      * @internal
      * Hash an element of type {@link HashableInput} into {@link Number}
      * Can be overrided as long as you return a value of type {@link Number}
      * Don't forget to use the seed when hashing, otherwise if some kind of randomness is in the process
      * you may have inconsistent behaviors between 2 runs.
      * @param element
      * @param seed
      * @returns A 64bits floating point {@link Number}
      */
      serialize(element, seed) {
        if (!seed) {
          seed = (0, _utils).getDefaultSeed();
        }
        return Number((0, _fnv1A).default(element, {
          seed
        }));
      }
      /**
      * (64-bits only) Hash a value into two values (in hex or integer format)
      * @param  value - The value to hash
      * @param  asInt - (optional) If True, the values will be returned as an integer. Otherwise, as hexadecimal values.
      * @param seed the seed used for hashing
      * @return The results of the hash functions applied to the value (in hex or integer)
      * @author Arnaud Grall & Thomas Minier
      */
      hashTwice(value, seed) {
        if (seed === void 0) {
          seed = (0, _utils).getDefaultSeed();
        }
        return {
          first: this.serialize(value, seed + 1),
          second: this.serialize(value, seed + 2)
        };
      }
      /**
      * Hash twice an element into their HEX string representations
      * @param value
      * @param seed
      * @returns TwoHashesTemplated<string>
      */
      hashTwiceAsString(value, seed) {
        const { first, second } = this.hashTwice(value, seed);
        return {
          first: (0, _utils).numberToHex(first),
          second: (0, _utils).numberToHex(second)
        };
      }
      /**
      * (64-bits only) Same as hashTwice but return Numbers and String equivalent
      * @param  val the value to hash
      * @param  seed the seed to change when hashing
      * @return TwoHashesIntAndString
      * @author Arnaud Grall
      */
      hashTwiceIntAndString(val, seed) {
        if (seed === void 0) {
          seed = (0, _utils).getDefaultSeed();
        }
        const one = this.hashIntAndString(val, seed + 1);
        const two = this.hashIntAndString(val, seed + 2);
        return {
          int: {
            first: one.int,
            second: two.int
          },
          string: {
            first: one.string,
            second: two.string
          }
        };
      }
      /**
      * Hash an item as an unsigned int
      * @param  elem - Element to hash
      * @param  seed - The hash seed. If its is UINT32 make sure to set the length to 32
      * @param  length - The length of hashes (defaults to 32 bits)
      * @return The hash value as an unsigned int
      * @author Arnaud Grall
      */
      hashAsInt(elem, seed) {
        if (seed === void 0) {
          seed = (0, _utils).getDefaultSeed();
        }
        return this.serialize(elem, seed);
      }
      /**
      * Hash an item and return its number and HEX string representation
      * @param  elem - Element to hash
      * @param  seed - The hash seed. If its is UINT32 make sure to set the length to 32
      * @param  base - The base in which the string will be returned, default: 16
      * @param  length - The length of hashes (defaults to 32 bits)
      * @return The item hased as an int and a string
      * @author Arnaud Grall
      */
      hashIntAndString(elem, seed) {
        const hash = this.hashAsInt(elem, seed);
        return {
          int: hash,
          string: (0, _utils).numberToHex(hash)
        };
      }
    };
    exports.default = Hashing;
  }
});

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// ../../../../../../node_modules/next/dist/shared/lib/bloom-filter/base-filter.js
var require_base_filter = __commonJS({
  "../../../../../../node_modules/next/dist/shared/lib/bloom-filter/base-filter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _interop_require_default = require_interop_require_default().default;
    var _hashing = _interop_require_default(require_hashing());
    var _utils = require_utils3();
    function randomInt32() {
      if (typeof window === "undefined" && process.env.NEXT_RUNTIME === "nodejs") {
        return require_crypto().randomBytes(4).readUInt32BE(0);
      }
      return crypto.getRandomValues(new Uint32Array(1))[0];
    }
    function seedrandom() {
      return {
        int32: randomInt32,
        quick: randomInt32
      };
    }
    var BaseFilter = class {
      /**
      * Get the seed used in this structure
      */
      get seed() {
        return this._seed;
      }
      /**
      * Set the seed for this structure
      * @param  seed the new seed that will be used in this structure
      */
      set seed(seed) {
        this._seed = seed;
        this._rng = seedrandom();
      }
      /**
      * Get a function used to draw random number
      * @return A factory function used to draw random integer
      */
      get random() {
        return this._rng;
      }
      /**
      * Return a next random seeded int32 integer
      * @returns
      */
      nextInt32() {
        return this._rng.int32();
      }
      /**
      * Save the current structure as a JSON
      */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      saveAsJSON() {
        throw new Error("not-implemented");
      }
      /**
      * Load an Object from a provided JSON object
      * @param json the JSON object to load
      * @return Return the Object loaded from the provided JSON object
      */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unused-vars
      static fromJSON(json) {
        throw new Error(`not-implemented`);
      }
      constructor() {
        this._seed = (0, _utils).getDefaultSeed();
        this._rng = seedrandom();
        this._hashing = new _hashing.default();
      }
    };
    exports.default = BaseFilter;
  }
});

// ../../../../../../node_modules/next/dist/shared/lib/bloom-filter/base64-arraybuffer.js
var require_base64_arraybuffer = __commonJS({
  "../../../../../../node_modules/next/dist/shared/lib/bloom-filter/base64-arraybuffer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.decode = exports.encode = void 0;
    var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var lookup = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
    for (let i = 0; i < chars.length; i++) {
      lookup[chars.charCodeAt(i)] = i;
    }
    var encode = (arraybuffer) => {
      let bytes = new Uint8Array(arraybuffer), i1, len = bytes.length, base64 = "";
      for (i1 = 0; i1 < len; i1 += 3) {
        base64 += chars[bytes[i1] >> 2];
        base64 += chars[(bytes[i1] & 3) << 4 | bytes[i1 + 1] >> 4];
        base64 += chars[(bytes[i1 + 1] & 15) << 2 | bytes[i1 + 2] >> 6];
        base64 += chars[bytes[i1 + 2] & 63];
      }
      if (len % 3 === 2) {
        base64 = base64.substring(0, base64.length - 1) + "=";
      } else if (len % 3 === 1) {
        base64 = base64.substring(0, base64.length - 2) + "==";
      }
      return base64;
    };
    exports.encode = encode;
    var decode = (base64) => {
      let bufferLength = base64.length * 0.75, len = base64.length, i2, p = 0, encoded1, encoded2, encoded3, encoded4;
      if (base64[base64.length - 1] === "=") {
        bufferLength--;
        if (base64[base64.length - 2] === "=") {
          bufferLength--;
        }
      }
      const arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
      for (i2 = 0; i2 < len; i2 += 4) {
        encoded1 = lookup[base64.charCodeAt(i2)];
        encoded2 = lookup[base64.charCodeAt(i2 + 1)];
        encoded3 = lookup[base64.charCodeAt(i2 + 2)];
        encoded4 = lookup[base64.charCodeAt(i2 + 3)];
        bytes[p++] = encoded1 << 2 | encoded2 >> 4;
        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
      }
      return arraybuffer;
    };
    exports.decode = decode;
  }
});

// ../../../../../../node_modules/next/dist/shared/lib/bloom-filter/bit-set.js
var require_bit_set = __commonJS({
  "../../../../../../node_modules/next/dist/shared/lib/bloom-filter/bit-set.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _base64Arraybuffer = require_base64_arraybuffer();
    var bitsPerWord = 8;
    var BitSet = class {
      /**
      * Returns the value of the bit at the given index
      * @param index position of the bit, zero-indexed
      */
      has(index) {
        const wordIndex = Math.floor(index / bitsPerWord);
        const mask = 1 << index % bitsPerWord;
        return (this.array[wordIndex] & mask) !== 0;
      }
      /**
      * Set the bit to true
      * @param index position of the bit, zero-indexed
      */
      add(index) {
        const wordIndex = Math.floor(index / bitsPerWord);
        const mask = 1 << index % bitsPerWord;
        this.array[wordIndex] = this.array[wordIndex] | mask;
      }
      /**
      * Returns the maximum true bit.
      */
      max() {
        for (let i = this.array.length - 1; i >= 0; i--) {
          const bits = this.array[i];
          if (bits) {
            return BitSet.highBit(bits) + i * bitsPerWord;
          }
        }
        return 0;
      }
      /**
      * Returns the number of true bits.
      */
      bitCount() {
        let result = 0;
        for (let i = 0; i < this.array.length; i++) {
          result += BitSet.countBits(this.array[i]);
        }
        return result;
      }
      /**
      * Returns true if the size and contents are identical.
      * @param other another BitSet
      */
      equals(other) {
        if (other.size !== this.size) {
          return false;
        }
        for (let i = 0; i < this.array.length; i++) {
          if (this.array[i] !== other.array[i]) {
            return false;
          }
        }
        return true;
      }
      /**
      * Returns a JSON-encodable object readable by {@link import}.
      */
      export() {
        return {
          size: this.size,
          content: (0, _base64Arraybuffer).encode(this.array)
        };
      }
      /**
      * Returns an object written by {@link export}.
      * @param data an object written by {@link export}
      */
      static import(data) {
        if (typeof data.size !== "number") {
          throw Error("BitSet missing size");
        }
        if (typeof data.content !== "string") {
          throw Error("BitSet: missing content");
        }
        const result = new BitSet(data.size);
        const buffer = (0, _base64Arraybuffer).decode(data.content);
        result.array = new Uint8Array(buffer);
        return result;
      }
      /**
      * Returns the index of the maximum bit in the number, or -1 for 0
      * @bits an unsigned 8-bit number
      * ```js
      * @example
      * BitSet.highBit(0) // returns -1
      * BitSet.highBit(5) // returns 2
      * ```
      */
      static highBit(bits) {
        let result = bitsPerWord - 1;
        let mask = 1 << result;
        while (result >= 0 && (mask & bits) !== mask) {
          mask >>>= 1;
          result--;
        }
        return result;
      }
      /**
      * Returns the number of true bits in the number
      * @bits an unsigned 8-bit number
      * @example
      * ```js
      * BitSet.countBits(0) // returns 0
      * BitSet.countBits(3) // returns 2
      * ```
      */
      static countBits(bits) {
        let result = bits & 1;
        while (bits !== 0) {
          bits = bits >>> 1;
          result += bits & 1;
        }
        return result;
      }
      /**
      * Constructor. All bits are initially set to false.
      * @param size the number of bits that can be stored. (This is NOT required to be a multiple of 8.)
      */
      constructor(size) {
        const diff = bitsPerWord - size % bitsPerWord;
        this.size = size + ([
          0,
          8
        ].includes(diff) ? 0 : diff);
        this.array = new Uint8Array(Math.ceil(this.size / bitsPerWord));
      }
    };
    exports.default = BitSet;
  }
});

// ../../../../../../node_modules/next/dist/shared/lib/bloom-filter/formulas.js
var require_formulas = __commonJS({
  "../../../../../../node_modules/next/dist/shared/lib/bloom-filter/formulas.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.optimalFilterSize = optimalFilterSize;
    exports.optimalHashes = optimalHashes;
    function optimalFilterSize(length, errorRate) {
      return Math.ceil(-(length * Math.log(errorRate) / Math.pow(Math.log(2), 2)));
    }
    function optimalHashes(size, length) {
      return Math.ceil(size / length * Math.log(2));
    }
  }
});

// ../../../../../../node_modules/next/dist/shared/lib/bloom-filter/index.js
var require_bloom_filter = __commonJS({
  "../../../../../../node_modules/next/dist/shared/lib/bloom-filter/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _interop_require_default = require_interop_require_default().default;
    var _baseFilter = _interop_require_default(require_base_filter());
    var _bitSet = _interop_require_default(require_bit_set());
    var _formulas = require_formulas();
    var BloomFilter = class extends _baseFilter.default {
      /**
      * Create an optimal bloom filter providing the maximum of elements stored and the error rate desired
      * @param  nbItems      - The maximum number of item to store
      * @param  errorRate  - The error rate desired for a maximum of items inserted
      * @return A new {@link BloomFilter}
      */
      static create(nbItems, errorRate) {
        const size = (0, _formulas).optimalFilterSize(nbItems, errorRate);
        const hashes = (0, _formulas).optimalHashes(size, nbItems);
        return new this(size, hashes);
      }
      /**
      * Build a new Bloom Filter from an existing iterable with a fixed error rate
      * @param items - The iterable used to populate the filter
      * @param errorRate - The error rate, i.e. 'false positive' rate, targeted by the filter
      * @param seed - The random number seed (optional)
      * @return A new Bloom Filter filled with the iterable's elements
      * @example
      * ```js
      * // create a filter with a false positive rate of 0.1
      * const filter = BloomFilter.from(['alice', 'bob', 'carl'], 0.1);
      * ```
      */
      static from(items, errorRate, seed) {
        const array = Array.from(items);
        const filter = BloomFilter.create(array.length, errorRate);
        if (typeof seed === "number") {
          filter.seed = seed;
        }
        array.forEach((element) => filter.add(element));
        return filter;
      }
      /**
      * Get the optimal size of the filter
      * @return The size of the filter
      */
      get size() {
        return this._size;
      }
      /**
      * Get the number of bits currently set in the filter
      * @return The filter length
      */
      get length() {
        return this._filter.bitCount();
      }
      /**
      * Add an element to the filter
      * @param element - The element to add
      * @example
      * ```js
      * const filter = new BloomFilter(15, 0.1);
      * filter.add('foo');
      * ```
      */
      add(element) {
        const indexes = this._hashing.getIndexes(element, this._size, this._nbHashes, this.seed);
        for (let i = 0; i < indexes.length; i++) {
          this._filter.add(indexes[i]);
        }
      }
      /**
      * Test an element for membership
      * @param element - The element to look for in the filter
      * @return False if the element is definitively not in the filter, True is the element might be in the filter
      * @example
      * ```js
      * const filter = new BloomFilter(15, 0.1);
      * filter.add('foo');
      * console.log(filter.has('foo')); // output: true
      * console.log(filter.has('bar')); // output: false
      * ```
      */
      has(element) {
        const indexes = this._hashing.getIndexes(element, this._size, this._nbHashes, this.seed);
        for (let i = 0; i < indexes.length; i++) {
          if (!this._filter.has(indexes[i])) {
            return false;
          }
        }
        return true;
      }
      /**
      * Get the current false positive rate (or error rate) of the filter
      * @return The current false positive rate of the filter
      * @example
      * ```js
      * const filter = new BloomFilter(15, 0.1);
      * console.log(filter.rate()); // output: something around 0.1
      * ```
      */
      rate() {
        return Math.pow(1 - Math.exp(-this.length / this._size), this._nbHashes);
      }
      /**
      * Check if another Bloom Filter is equal to this one
      * @param  other - The filter to compare to this one
      * @return True if they are equal, false otherwise
      */
      equals(other) {
        if (this._size !== other._size || this._nbHashes !== other._nbHashes) {
          return false;
        }
        return this._filter.equals(other._filter);
      }
      export() {
        return {
          bitset: this._filter.export(),
          hashes: this._nbHashes,
          size: this._size
        };
      }
      import(data) {
        this._filter = _bitSet.default.import(data.bitset);
      }
      /**
      * Constructor
      * @param size - The number of cells
      * @param nbHashes - The number of hash functions used
      */
      constructor(size, nbHashes) {
        super();
        if (nbHashes < 1) {
          throw new Error(`A BloomFilter cannot uses less than one hash function, while you tried to use ${nbHashes}.`);
        }
        this._size = size;
        this._nbHashes = nbHashes;
        this._filter = new _bitSet.default(size);
      }
    };
    exports.BloomFilter = BloomFilter;
  }
});

// ../../../../../../node_modules/next/dist/shared/lib/router/router.js
var require_router = __commonJS({
  "../../../../../../node_modules/next/dist/shared/lib/router/router.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.matchesMiddleware = matchesMiddleware;
    exports.createKey = createKey;
    exports.default = void 0;
    var _async_to_generator = require_async_to_generator().default;
    var _extends = require_extends().default;
    var _interop_require_default = require_interop_require_default().default;
    var _interop_require_wildcard = require_interop_require_wildcard().default;
    var _removeTrailingSlash = require_remove_trailing_slash();
    var _routeLoader = require_route_loader();
    var _script = require_script();
    var _isError = _interop_require_wildcard(require_is_error());
    var _denormalizePagePath = require_denormalize_page_path();
    var _normalizeLocalePath = require_normalize_locale_path();
    var _mitt = _interop_require_default(require_mitt());
    var _utils = require_utils2();
    var _isDynamic = require_is_dynamic();
    var _parseRelativeUrl = require_parse_relative_url();
    var _resolveRewrites = _interop_require_default(require_resolve_rewrites());
    var _routeMatcher = require_route_matcher();
    var _routeRegex = require_route_regex();
    var _formatUrl = require_format_url();
    var _detectDomainLocale = require_detect_domain_locale2();
    var _parsePath = require_parse_path();
    var _addLocale = require_add_locale2();
    var _removeLocale = require_remove_locale();
    var _removeBasePath = require_remove_base_path();
    var _addBasePath = require_add_base_path();
    var _hasBasePath = require_has_base_path();
    var _isApiRoute = require_is_api_route();
    var _getNextPathnameInfo = require_get_next_pathname_info();
    var _formatNextPathnameInfo = require_format_next_pathname_info();
    var _compareStates = require_compare_states();
    var _isLocalUrl = require_is_local_url();
    var _isBot = require_is_bot();
    var _omit = require_omit();
    var _resolveHref = require_resolve_href();
    var _interpolateAs = require_interpolate_as();
    var _handleSmoothScroll = require_handle_smooth_scroll();
    function buildCancellationError() {
      return Object.assign(new Error("Route Cancelled"), {
        cancelled: true
      });
    }
    function matchesMiddleware(options) {
      return _matchesMiddleware.apply(this, arguments);
    }
    function _matchesMiddleware() {
      _matchesMiddleware = _async_to_generator(function* (options) {
        const matchers = yield Promise.resolve(options.router.pageLoader.getMiddleware());
        if (!matchers)
          return false;
        const { pathname: asPathname } = (0, _parsePath).parsePath(options.asPath);
        const cleanedAs = (0, _hasBasePath).hasBasePath(asPathname) ? (0, _removeBasePath).removeBasePath(asPathname) : asPathname;
        const asWithBasePathAndLocale = (0, _addBasePath).addBasePath((0, _addLocale).addLocale(cleanedAs, options.locale));
        return matchers.some((m) => new RegExp(m.regexp).test(asWithBasePathAndLocale));
      });
      return _matchesMiddleware.apply(this, arguments);
    }
    function stripOrigin(url) {
      const origin = (0, _utils).getLocationOrigin();
      return url.startsWith(origin) ? url.substring(origin.length) : url;
    }
    function prepareUrlAs(router, url, as) {
      let [resolvedHref, resolvedAs] = (0, _resolveHref).resolveHref(router, url, true);
      const origin = (0, _utils).getLocationOrigin();
      const hrefWasAbsolute = resolvedHref.startsWith(origin);
      const asWasAbsolute = resolvedAs && resolvedAs.startsWith(origin);
      resolvedHref = stripOrigin(resolvedHref);
      resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;
      const preparedUrl = hrefWasAbsolute ? resolvedHref : (0, _addBasePath).addBasePath(resolvedHref);
      const preparedAs = as ? stripOrigin((0, _resolveHref).resolveHref(router, as)) : resolvedAs || resolvedHref;
      return {
        url: preparedUrl,
        as: asWasAbsolute ? preparedAs : (0, _addBasePath).addBasePath(preparedAs)
      };
    }
    function resolveDynamicRoute(pathname, pages) {
      const cleanPathname = (0, _removeTrailingSlash).removeTrailingSlash((0, _denormalizePagePath).denormalizePagePath(pathname));
      if (cleanPathname === "/404" || cleanPathname === "/_error") {
        return pathname;
      }
      if (!pages.includes(cleanPathname)) {
        pages.some((page) => {
          if ((0, _isDynamic).isDynamicRoute(page) && (0, _routeRegex).getRouteRegex(page).re.test(cleanPathname)) {
            pathname = page;
            return true;
          }
        });
      }
      return (0, _removeTrailingSlash).removeTrailingSlash(pathname);
    }
    function getMiddlewareData(source, response, options) {
      const nextConfig = {
        basePath: options.router.basePath,
        i18n: {
          locales: options.router.locales
        },
        trailingSlash: Boolean(process.env.__NEXT_TRAILING_SLASH)
      };
      const rewriteHeader = response.headers.get("x-nextjs-rewrite");
      let rewriteTarget = rewriteHeader || response.headers.get("x-nextjs-matched-path");
      const matchedPath = response.headers.get("x-matched-path");
      if (matchedPath && !rewriteTarget && !matchedPath.includes("__next_data_catchall") && !matchedPath.includes("/_error") && !matchedPath.includes("/404")) {
        rewriteTarget = matchedPath;
      }
      if (rewriteTarget) {
        if (rewriteTarget.startsWith("/") || process.env.__NEXT_EXTERNAL_MIDDLEWARE_REWRITE_RESOLVE) {
          const parsedRewriteTarget = (0, _parseRelativeUrl).parseRelativeUrl(rewriteTarget);
          const pathnameInfo = (0, _getNextPathnameInfo).getNextPathnameInfo(parsedRewriteTarget.pathname, {
            nextConfig,
            parseData: true
          });
          let fsPathname = (0, _removeTrailingSlash).removeTrailingSlash(pathnameInfo.pathname);
          return Promise.all([
            options.router.pageLoader.getPageList(),
            (0, _routeLoader).getClientBuildManifest()
          ]).then(([pages, { __rewrites: rewrites }]) => {
            let as = (0, _addLocale).addLocale(pathnameInfo.pathname, pathnameInfo.locale);
            if ((0, _isDynamic).isDynamicRoute(as) || !rewriteHeader && pages.includes((0, _normalizeLocalePath).normalizeLocalePath((0, _removeBasePath).removeBasePath(as), options.router.locales).pathname)) {
              const parsedSource = (0, _getNextPathnameInfo).getNextPathnameInfo((0, _parseRelativeUrl).parseRelativeUrl(source).pathname, {
                parseData: true
              });
              as = (0, _addBasePath).addBasePath(parsedSource.pathname);
              parsedRewriteTarget.pathname = as;
            }
            if (process.env.__NEXT_HAS_REWRITES) {
              const result = (0, _resolveRewrites).default(as, pages, rewrites, parsedRewriteTarget.query, (path) => resolveDynamicRoute(path, pages), options.router.locales);
              if (result.matchedPage) {
                parsedRewriteTarget.pathname = result.parsedAs.pathname;
                as = parsedRewriteTarget.pathname;
                Object.assign(parsedRewriteTarget.query, result.parsedAs.query);
              }
            } else if (!pages.includes(fsPathname)) {
              const resolvedPathname = resolveDynamicRoute(fsPathname, pages);
              if (resolvedPathname !== fsPathname) {
                fsPathname = resolvedPathname;
              }
            }
            const resolvedHref = !pages.includes(fsPathname) ? resolveDynamicRoute((0, _normalizeLocalePath).normalizeLocalePath((0, _removeBasePath).removeBasePath(parsedRewriteTarget.pathname), options.router.locales).pathname, pages) : fsPathname;
            if ((0, _isDynamic).isDynamicRoute(resolvedHref)) {
              const matches = (0, _routeMatcher).getRouteMatcher((0, _routeRegex).getRouteRegex(resolvedHref))(as);
              Object.assign(parsedRewriteTarget.query, matches || {});
            }
            return {
              type: "rewrite",
              parsedAs: parsedRewriteTarget,
              resolvedHref
            };
          });
        }
        const src = (0, _parsePath).parsePath(source);
        const pathname = (0, _formatNextPathnameInfo).formatNextPathnameInfo(_extends({}, (0, _getNextPathnameInfo).getNextPathnameInfo(src.pathname, {
          nextConfig,
          parseData: true
        }), {
          defaultLocale: options.router.defaultLocale,
          buildId: ""
        }));
        return Promise.resolve({
          type: "redirect-external",
          destination: `${pathname}${src.query}${src.hash}`
        });
      }
      const redirectTarget = response.headers.get("x-nextjs-redirect");
      if (redirectTarget) {
        if (redirectTarget.startsWith("/")) {
          const src = (0, _parsePath).parsePath(redirectTarget);
          const pathname = (0, _formatNextPathnameInfo).formatNextPathnameInfo(_extends({}, (0, _getNextPathnameInfo).getNextPathnameInfo(src.pathname, {
            nextConfig,
            parseData: true
          }), {
            defaultLocale: options.router.defaultLocale,
            buildId: ""
          }));
          return Promise.resolve({
            type: "redirect-internal",
            newAs: `${pathname}${src.query}${src.hash}`,
            newUrl: `${pathname}${src.query}${src.hash}`
          });
        }
        return Promise.resolve({
          type: "redirect-external",
          destination: redirectTarget
        });
      }
      return Promise.resolve({
        type: "next"
      });
    }
    function withMiddlewareEffects(options) {
      return _withMiddlewareEffects.apply(this, arguments);
    }
    function _withMiddlewareEffects() {
      _withMiddlewareEffects = _async_to_generator(function* (options) {
        const matches = yield matchesMiddleware(options);
        if (!matches || !options.fetchData) {
          return null;
        }
        try {
          const data = yield options.fetchData();
          const effect = yield getMiddlewareData(data.dataHref, data.response, options);
          return {
            dataHref: data.dataHref,
            json: data.json,
            response: data.response,
            text: data.text,
            cacheKey: data.cacheKey,
            effect
          };
        } catch (e) {
          return null;
        }
      });
      return _withMiddlewareEffects.apply(this, arguments);
    }
    var manualScrollRestoration = process.env.__NEXT_SCROLL_RESTORATION && typeof window !== "undefined" && "scrollRestoration" in window.history && !!function() {
      try {
        let v = "__next";
        return sessionStorage.setItem(v, v), sessionStorage.removeItem(v), true;
      } catch (n) {
      }
    }();
    var SSG_DATA_NOT_FOUND = Symbol("SSG_DATA_NOT_FOUND");
    function fetchRetry(url, attempts, options) {
      return fetch(url, {
        // Cookies are required to be present for Next.js' SSG "Preview Mode".
        // Cookies may also be required for `getServerSideProps`.
        //
        // > `fetch` wont send cookies, unless you set the credentials init
        // > option.
        // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch
        //
        // > For maximum browser compatibility when it comes to sending &
        // > receiving cookies, always supply the `credentials: 'same-origin'`
        // > option instead of relying on the default.
        // https://github.com/github/fetch#caveats
        credentials: "same-origin",
        method: options.method || "GET",
        headers: Object.assign({}, options.headers, {
          "x-nextjs-data": "1"
        })
      }).then((response) => {
        return !response.ok && attempts > 1 && response.status >= 500 ? fetchRetry(url, attempts - 1, options) : response;
      });
    }
    function tryToParseAsJSON(text) {
      try {
        return JSON.parse(text);
      } catch (error) {
        return null;
      }
    }
    function fetchNextData({ dataHref, inflightCache, isPrefetch, hasMiddleware, isServerRender, parseJSON, persistCache, isBackground, unstable_skipClientCache }) {
      const { href: cacheKey } = new URL(dataHref, window.location.href);
      var ref1;
      const getData = (params) => {
        return fetchRetry(dataHref, isServerRender ? 3 : 1, {
          headers: Object.assign({}, isPrefetch ? {
            purpose: "prefetch"
          } : {}, isPrefetch && hasMiddleware ? {
            "x-middleware-prefetch": "1"
          } : {}),
          method: (ref1 = params == null ? void 0 : params.method) != null ? ref1 : "GET"
        }).then((response) => {
          if (response.ok && (params == null ? void 0 : params.method) === "HEAD") {
            return {
              dataHref,
              response,
              text: "",
              json: {},
              cacheKey
            };
          }
          return response.text().then((text) => {
            if (!response.ok) {
              if (hasMiddleware && [
                301,
                302,
                307,
                308
              ].includes(response.status)) {
                return {
                  dataHref,
                  response,
                  text,
                  json: {},
                  cacheKey
                };
              }
              if (response.status === 404) {
                var ref;
                if ((ref = tryToParseAsJSON(text)) == null ? void 0 : ref.notFound) {
                  return {
                    dataHref,
                    json: {
                      notFound: SSG_DATA_NOT_FOUND
                    },
                    response,
                    text,
                    cacheKey
                  };
                }
              }
              const error = new Error(`Failed to load static props`);
              if (!isServerRender) {
                (0, _routeLoader).markAssetError(error);
              }
              throw error;
            }
            return {
              dataHref,
              json: parseJSON ? tryToParseAsJSON(text) : null,
              response,
              text,
              cacheKey
            };
          });
        }).then((data) => {
          if (!persistCache || true) {
            delete inflightCache[cacheKey];
          }
          return data;
        }).catch((err) => {
          if (!unstable_skipClientCache) {
            delete inflightCache[cacheKey];
          }
          if (
            // chrome
            err.message === "Failed to fetch" || // firefox
            err.message === "NetworkError when attempting to fetch resource." || // safari
            err.message === "Load failed"
          ) {
            (0, _routeLoader).markAssetError(err);
          }
          throw err;
        });
      };
      if (unstable_skipClientCache && persistCache) {
        return getData({}).then((data) => {
          inflightCache[cacheKey] = Promise.resolve(data);
          return data;
        });
      }
      if (inflightCache[cacheKey] !== void 0) {
        return inflightCache[cacheKey];
      }
      return inflightCache[cacheKey] = getData(isBackground ? {
        method: "HEAD"
      } : {});
    }
    function createKey() {
      return Math.random().toString(36).slice(2, 10);
    }
    function handleHardNavigation({ url, router }) {
      if (url === (0, _addBasePath).addBasePath((0, _addLocale).addLocale(router.asPath, router.locale))) {
        throw new Error(`Invariant: attempted to hard navigate to the same URL ${url} ${location.href}`);
      }
      window.location.href = url;
    }
    var getCancelledHandler = ({ route, router }) => {
      let cancelled = false;
      const cancel = router.clc = () => {
        cancelled = true;
      };
      const handleCancelled = () => {
        if (cancelled) {
          const error = new Error(`Abort fetching component for route: "${route}"`);
          error.cancelled = true;
          throw error;
        }
        if (cancel === router.clc) {
          router.clc = null;
        }
      };
      return handleCancelled;
    };
    var Router = class {
      reload() {
        window.location.reload();
      }
      /**
      * Go back in history
      */
      back() {
        window.history.back();
      }
      /**
      * Go forward in history
      */
      forward() {
        window.history.forward();
      }
      /**
      * Performs a `pushState` with arguments
      * @param url of the route
      * @param as masks `url` for the browser
      * @param options object you can define `shallow` and other options
      */
      push(url, as, options = {}) {
        if (process.env.__NEXT_SCROLL_RESTORATION) {
          if (manualScrollRestoration) {
            try {
              sessionStorage.setItem("__next_scroll_" + this._key, JSON.stringify({
                x: self.pageXOffset,
                y: self.pageYOffset
              }));
            } catch (e) {
            }
          }
        }
        ({ url, as } = prepareUrlAs(this, url, as));
        return this.change("pushState", url, as, options);
      }
      /**
      * Performs a `replaceState` with arguments
      * @param url of the route
      * @param as masks `url` for the browser
      * @param options object you can define `shallow` and other options
      */
      replace(url, as, options = {}) {
        ({ url, as } = prepareUrlAs(this, url, as));
        return this.change("replaceState", url, as, options);
      }
      _bfl(as, resolvedAs, locale, skipNavigate) {
        var _this = this;
        return _async_to_generator(function* () {
          if (process.env.__NEXT_CLIENT_ROUTER_FILTER_ENABLED) {
            let matchesBflStatic = false;
            let matchesBflDynamic = false;
            for (const curAs of [
              as,
              resolvedAs
            ]) {
              if (curAs) {
                const asNoSlash = (0, _removeTrailingSlash).removeTrailingSlash(new URL(curAs, "http://n").pathname);
                const asNoSlashLocale = (0, _addBasePath).addBasePath((0, _addLocale).addLocale(asNoSlash, locale || _this.locale));
                if (asNoSlash !== (0, _removeTrailingSlash).removeTrailingSlash(new URL(_this.asPath, "http://n").pathname)) {
                  var ref, ref2;
                  matchesBflStatic = matchesBflStatic || !!((ref = _this._bfl_s) == null ? void 0 : ref.has(asNoSlash)) || !!((ref2 = _this._bfl_s) == null ? void 0 : ref2.has(asNoSlashLocale));
                  for (const normalizedAS of [
                    asNoSlash,
                    asNoSlashLocale
                  ]) {
                    const curAsParts = normalizedAS.split("/");
                    for (let i = 0; !matchesBflDynamic && i < curAsParts.length + 1; i++) {
                      var ref3;
                      const currentPart = curAsParts.slice(0, i).join("/");
                      if (currentPart && ((ref3 = _this._bfl_d) == null ? void 0 : ref3.has(currentPart))) {
                        matchesBflDynamic = true;
                        break;
                      }
                    }
                  }
                  if (matchesBflStatic || matchesBflDynamic) {
                    if (skipNavigate) {
                      return true;
                    }
                    handleHardNavigation({
                      url: (0, _addBasePath).addBasePath((0, _addLocale).addLocale(as, locale || _this.locale, _this.defaultLocale)),
                      router: _this
                    });
                    return new Promise(() => {
                    });
                  }
                }
              }
            }
          }
          return false;
        })();
      }
      change(method, url, as, options, forcedScroll) {
        var _this = this;
        return _async_to_generator(function* () {
          var ref;
          if (!(0, _isLocalUrl).isLocalURL(url)) {
            handleHardNavigation({
              url,
              router: _this
            });
            return false;
          }
          const isQueryUpdating = options._h === 1;
          if (!isQueryUpdating && !options.shallow) {
            yield _this._bfl(as, void 0, options.locale);
          }
          let shouldResolveHref = isQueryUpdating || options._shouldResolveHref || (0, _parsePath).parsePath(url).pathname === (0, _parsePath).parsePath(as).pathname;
          const nextState = _extends({}, _this.state);
          const readyStateChange = _this.isReady !== true;
          _this.isReady = true;
          const isSsr = _this.isSsr;
          if (!isQueryUpdating) {
            _this.isSsr = false;
          }
          if (isQueryUpdating && _this.clc) {
            return false;
          }
          const prevLocale = nextState.locale;
          if (process.env.__NEXT_I18N_SUPPORT) {
            nextState.locale = options.locale === false ? _this.defaultLocale : options.locale || nextState.locale;
            if (typeof options.locale === "undefined") {
              options.locale = nextState.locale;
            }
            const parsedAs = (0, _parseRelativeUrl).parseRelativeUrl((0, _hasBasePath).hasBasePath(as) ? (0, _removeBasePath).removeBasePath(as) : as);
            const localePathResult = (0, _normalizeLocalePath).normalizeLocalePath(parsedAs.pathname, _this.locales);
            if (localePathResult.detectedLocale) {
              nextState.locale = localePathResult.detectedLocale;
              parsedAs.pathname = (0, _addBasePath).addBasePath(parsedAs.pathname);
              as = (0, _formatUrl).formatWithValidation(parsedAs);
              url = (0, _addBasePath).addBasePath((0, _normalizeLocalePath).normalizeLocalePath((0, _hasBasePath).hasBasePath(url) ? (0, _removeBasePath).removeBasePath(url) : url, _this.locales).pathname);
            }
            let didNavigate = false;
            if (process.env.__NEXT_I18N_SUPPORT) {
              var ref4;
              if (!((ref4 = _this.locales) == null ? void 0 : ref4.includes(nextState.locale))) {
                parsedAs.pathname = (0, _addLocale).addLocale(parsedAs.pathname, nextState.locale);
                handleHardNavigation({
                  url: (0, _formatUrl).formatWithValidation(parsedAs),
                  router: _this
                });
                didNavigate = true;
              }
            }
            const detectedDomain = (0, _detectDomainLocale).detectDomainLocale(_this.domainLocales, void 0, nextState.locale);
            if (process.env.__NEXT_I18N_SUPPORT) {
              if (!didNavigate && detectedDomain && _this.isLocaleDomain && self.location.hostname !== detectedDomain.domain) {
                const asNoBasePath = (0, _removeBasePath).removeBasePath(as);
                handleHardNavigation({
                  url: `http${detectedDomain.http ? "" : "s"}://${detectedDomain.domain}${(0, _addBasePath).addBasePath(`${nextState.locale === detectedDomain.defaultLocale ? "" : `/${nextState.locale}`}${asNoBasePath === "/" ? "" : asNoBasePath}` || "/")}`,
                  router: _this
                });
                didNavigate = true;
              }
            }
            if (didNavigate) {
              return new Promise(() => {
              });
            }
          }
          if (_utils.ST) {
            performance.mark("routeChange");
          }
          const { shallow = false, scroll = true } = options;
          const routeProps = {
            shallow
          };
          if (_this._inFlightRoute && _this.clc) {
            if (!isSsr) {
              Router.events.emit("routeChangeError", buildCancellationError(), _this._inFlightRoute, routeProps);
            }
            _this.clc();
            _this.clc = null;
          }
          as = (0, _addBasePath).addBasePath((0, _addLocale).addLocale((0, _hasBasePath).hasBasePath(as) ? (0, _removeBasePath).removeBasePath(as) : as, options.locale, _this.defaultLocale));
          const cleanedAs = (0, _removeLocale).removeLocale((0, _hasBasePath).hasBasePath(as) ? (0, _removeBasePath).removeBasePath(as) : as, nextState.locale);
          _this._inFlightRoute = as;
          const localeChange = prevLocale !== nextState.locale;
          if (!isQueryUpdating && _this.onlyAHashChange(cleanedAs) && !localeChange) {
            nextState.asPath = cleanedAs;
            Router.events.emit("hashChangeStart", as, routeProps);
            _this.changeState(method, url, as, _extends({}, options, {
              scroll: false
            }));
            if (scroll) {
              _this.scrollToHash(cleanedAs);
            }
            try {
              yield _this.set(nextState, _this.components[nextState.route], null);
            } catch (err) {
              if ((0, _isError).default(err) && err.cancelled) {
                Router.events.emit("routeChangeError", err, cleanedAs, routeProps);
              }
              throw err;
            }
            Router.events.emit("hashChangeComplete", as, routeProps);
            return true;
          }
          let parsed = (0, _parseRelativeUrl).parseRelativeUrl(url);
          let { pathname, query } = parsed;
          if ((ref = _this.components[pathname]) == null ? void 0 : ref.__appRouter) {
            handleHardNavigation({
              url: as,
              router: _this
            });
            return new Promise(() => {
            });
          }
          let pages, rewrites;
          try {
            [pages, { __rewrites: rewrites }] = yield Promise.all([
              _this.pageLoader.getPageList(),
              (0, _routeLoader).getClientBuildManifest(),
              _this.pageLoader.getMiddleware()
            ]);
          } catch (err) {
            handleHardNavigation({
              url: as,
              router: _this
            });
            return false;
          }
          if (!_this.urlIsNew(cleanedAs) && !localeChange) {
            method = "replaceState";
          }
          let resolvedAs = as;
          pathname = pathname ? (0, _removeTrailingSlash).removeTrailingSlash((0, _removeBasePath).removeBasePath(pathname)) : pathname;
          let route = (0, _removeTrailingSlash).removeTrailingSlash(pathname);
          const parsedAsPathname = as.startsWith("/") && (0, _parseRelativeUrl).parseRelativeUrl(as).pathname;
          const isMiddlewareRewrite = !!(parsedAsPathname && route !== parsedAsPathname && (!(0, _isDynamic).isDynamicRoute(route) || !(0, _routeMatcher).getRouteMatcher((0, _routeRegex).getRouteRegex(route))(parsedAsPathname)));
          const isMiddlewareMatch = !options.shallow && (yield matchesMiddleware({
            asPath: as,
            locale: nextState.locale,
            router: _this
          }));
          if (isQueryUpdating && isMiddlewareMatch) {
            shouldResolveHref = false;
          }
          if (shouldResolveHref && pathname !== "/_error") {
            options._shouldResolveHref = true;
            if (process.env.__NEXT_HAS_REWRITES && as.startsWith("/")) {
              const rewritesResult = (0, _resolveRewrites).default((0, _addBasePath).addBasePath((0, _addLocale).addLocale(cleanedAs, nextState.locale), true), pages, rewrites, query, (p) => resolveDynamicRoute(p, pages), _this.locales);
              if (rewritesResult.externalDest) {
                handleHardNavigation({
                  url: as,
                  router: _this
                });
                return true;
              }
              if (!isMiddlewareMatch) {
                resolvedAs = rewritesResult.asPath;
              }
              if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {
                pathname = rewritesResult.resolvedHref;
                parsed.pathname = (0, _addBasePath).addBasePath(pathname);
                if (!isMiddlewareMatch) {
                  url = (0, _formatUrl).formatWithValidation(parsed);
                }
              }
            } else {
              parsed.pathname = resolveDynamicRoute(pathname, pages);
              if (parsed.pathname !== pathname) {
                pathname = parsed.pathname;
                parsed.pathname = (0, _addBasePath).addBasePath(pathname);
                if (!isMiddlewareMatch) {
                  url = (0, _formatUrl).formatWithValidation(parsed);
                }
              }
            }
          }
          if (!(0, _isLocalUrl).isLocalURL(as)) {
            if (true) {
              throw new Error(`Invalid href: "${url}" and as: "${as}", received relative href and external as
See more info: https://nextjs.org/docs/messages/invalid-relative-url-external-as`);
            }
            handleHardNavigation({
              url: as,
              router: _this
            });
            return false;
          }
          resolvedAs = (0, _removeLocale).removeLocale((0, _removeBasePath).removeBasePath(resolvedAs), nextState.locale);
          route = (0, _removeTrailingSlash).removeTrailingSlash(pathname);
          let routeMatch = false;
          if ((0, _isDynamic).isDynamicRoute(route)) {
            const parsedAs = (0, _parseRelativeUrl).parseRelativeUrl(resolvedAs);
            const asPathname = parsedAs.pathname;
            const routeRegex = (0, _routeRegex).getRouteRegex(route);
            routeMatch = (0, _routeMatcher).getRouteMatcher(routeRegex)(asPathname);
            const shouldInterpolate = route === asPathname;
            const interpolatedAs = shouldInterpolate ? (0, _interpolateAs).interpolateAs(route, asPathname, query) : {};
            if (!routeMatch || shouldInterpolate && !interpolatedAs.result) {
              const missingParams = Object.keys(routeRegex.groups).filter((param) => !query[param] && !routeRegex.groups[param].optional);
              if (missingParams.length > 0 && !isMiddlewareMatch) {
                if (true) {
                  console.warn(`${shouldInterpolate ? `Interpolating href` : `Mismatching \`as\` and \`href\``} failed to manually provide the params: ${missingParams.join(", ")} in the \`href\`'s \`query\``);
                }
                throw new Error((shouldInterpolate ? `The provided \`href\` (${url}) value is missing query values (${missingParams.join(", ")}) to be interpolated properly. ` : `The provided \`as\` value (${asPathname}) is incompatible with the \`href\` value (${route}). `) + `Read more: https://nextjs.org/docs/messages/${shouldInterpolate ? "href-interpolation-failed" : "incompatible-href-as"}`);
              }
            } else if (shouldInterpolate) {
              as = (0, _formatUrl).formatWithValidation(Object.assign({}, parsedAs, {
                pathname: interpolatedAs.result,
                query: (0, _omit).omit(query, interpolatedAs.params)
              }));
            } else {
              Object.assign(query, routeMatch);
            }
          }
          if (!isQueryUpdating) {
            Router.events.emit("routeChangeStart", as, routeProps);
          }
          const isErrorRoute = _this.pathname === "/404" || _this.pathname === "/_error";
          try {
            var ref5, ref6, ref7;
            let routeInfo = yield _this.getRouteInfo({
              route,
              pathname,
              query,
              as,
              resolvedAs,
              routeProps,
              locale: nextState.locale,
              isPreview: nextState.isPreview,
              hasMiddleware: isMiddlewareMatch,
              unstable_skipClientCache: options.unstable_skipClientCache,
              isQueryUpdating: isQueryUpdating && !_this.isFallback,
              isMiddlewareRewrite
            });
            if (!isQueryUpdating && !options.shallow) {
              yield _this._bfl(as, "resolvedAs" in routeInfo ? routeInfo.resolvedAs : void 0, nextState.locale);
            }
            if ("route" in routeInfo && isMiddlewareMatch) {
              pathname = routeInfo.route || route;
              route = pathname;
              if (!routeProps.shallow) {
                query = Object.assign({}, routeInfo.query || {}, query);
              }
              const cleanedParsedPathname = (0, _hasBasePath).hasBasePath(parsed.pathname) ? (0, _removeBasePath).removeBasePath(parsed.pathname) : parsed.pathname;
              if (routeMatch && pathname !== cleanedParsedPathname) {
                Object.keys(routeMatch).forEach((key) => {
                  if (routeMatch && query[key] === routeMatch[key]) {
                    delete query[key];
                  }
                });
              }
              if ((0, _isDynamic).isDynamicRoute(pathname)) {
                const prefixedAs = !routeProps.shallow && routeInfo.resolvedAs ? routeInfo.resolvedAs : (0, _addBasePath).addBasePath((0, _addLocale).addLocale(new URL(as, location.href).pathname, nextState.locale), true);
                let rewriteAs = prefixedAs;
                if ((0, _hasBasePath).hasBasePath(rewriteAs)) {
                  rewriteAs = (0, _removeBasePath).removeBasePath(rewriteAs);
                }
                if (process.env.__NEXT_I18N_SUPPORT) {
                  const localeResult = (0, _normalizeLocalePath).normalizeLocalePath(rewriteAs, _this.locales);
                  nextState.locale = localeResult.detectedLocale || nextState.locale;
                  rewriteAs = localeResult.pathname;
                }
                const routeRegex = (0, _routeRegex).getRouteRegex(pathname);
                const curRouteMatch = (0, _routeMatcher).getRouteMatcher(routeRegex)(new URL(rewriteAs, location.href).pathname);
                if (curRouteMatch) {
                  Object.assign(query, curRouteMatch);
                }
              }
            }
            if ("type" in routeInfo) {
              if (routeInfo.type === "redirect-internal") {
                return _this.change(method, routeInfo.newUrl, routeInfo.newAs, options);
              } else {
                handleHardNavigation({
                  url: routeInfo.destination,
                  router: _this
                });
                return new Promise(() => {
                });
              }
            }
            const component = routeInfo.Component;
            if (component && component.unstable_scriptLoader) {
              const scripts = [].concat(component.unstable_scriptLoader());
              scripts.forEach((script) => {
                (0, _script).handleClientScriptLoad(script.props);
              });
            }
            if ((routeInfo.__N_SSG || routeInfo.__N_SSP) && routeInfo.props) {
              if (routeInfo.props.pageProps && routeInfo.props.pageProps.__N_REDIRECT) {
                options.locale = false;
                const destination = routeInfo.props.pageProps.__N_REDIRECT;
                if (destination.startsWith("/") && routeInfo.props.pageProps.__N_REDIRECT_BASE_PATH !== false) {
                  const parsedHref = (0, _parseRelativeUrl).parseRelativeUrl(destination);
                  parsedHref.pathname = resolveDynamicRoute(parsedHref.pathname, pages);
                  const { url: newUrl, as: newAs } = prepareUrlAs(_this, destination, destination);
                  return _this.change(method, newUrl, newAs, options);
                }
                handleHardNavigation({
                  url: destination,
                  router: _this
                });
                return new Promise(() => {
                });
              }
              nextState.isPreview = !!routeInfo.props.__N_PREVIEW;
              if (routeInfo.props.notFound === SSG_DATA_NOT_FOUND) {
                let notFoundRoute;
                try {
                  yield _this.fetchComponent("/404");
                  notFoundRoute = "/404";
                } catch (_) {
                  notFoundRoute = "/_error";
                }
                routeInfo = yield _this.getRouteInfo({
                  route: notFoundRoute,
                  pathname: notFoundRoute,
                  query,
                  as,
                  resolvedAs,
                  routeProps: {
                    shallow: false
                  },
                  locale: nextState.locale,
                  isPreview: nextState.isPreview,
                  isNotFound: true
                });
                if ("type" in routeInfo) {
                  throw new Error(`Unexpected middleware effect on /404`);
                }
              }
            }
            if (isQueryUpdating && _this.pathname === "/_error" && ((ref5 = self.__NEXT_DATA__.props) == null ? void 0 : (ref6 = ref5.pageProps) == null ? void 0 : ref6.statusCode) === 500 && ((ref7 = routeInfo.props) == null ? void 0 : ref7.pageProps)) {
              routeInfo.props.pageProps.statusCode = 500;
            }
            var _route;
            const isValidShallowRoute = options.shallow && nextState.route === ((_route = routeInfo.route) != null ? _route : route);
            var _scroll;
            const shouldScroll = (_scroll = options.scroll) != null ? _scroll : !isQueryUpdating && !isValidShallowRoute;
            const resetScroll = shouldScroll ? {
              x: 0,
              y: 0
            } : null;
            const upcomingScrollState = forcedScroll != null ? forcedScroll : resetScroll;
            const upcomingRouterState = _extends({}, nextState, {
              route,
              pathname,
              query,
              asPath: cleanedAs,
              isFallback: false
            });
            if (isQueryUpdating && isErrorRoute) {
              var ref8, ref9, ref10;
              routeInfo = yield _this.getRouteInfo({
                route: _this.pathname,
                pathname: _this.pathname,
                query,
                as,
                resolvedAs,
                routeProps: {
                  shallow: false
                },
                locale: nextState.locale,
                isPreview: nextState.isPreview,
                isQueryUpdating: isQueryUpdating && !_this.isFallback
              });
              if ("type" in routeInfo) {
                throw new Error(`Unexpected middleware effect on ${_this.pathname}`);
              }
              if (_this.pathname === "/_error" && ((ref8 = self.__NEXT_DATA__.props) == null ? void 0 : (ref9 = ref8.pageProps) == null ? void 0 : ref9.statusCode) === 500 && ((ref10 = routeInfo.props) == null ? void 0 : ref10.pageProps)) {
                routeInfo.props.pageProps.statusCode = 500;
              }
              try {
                yield _this.set(upcomingRouterState, routeInfo, upcomingScrollState);
              } catch (err) {
                if ((0, _isError).default(err) && err.cancelled) {
                  Router.events.emit("routeChangeError", err, cleanedAs, routeProps);
                }
                throw err;
              }
              return true;
            }
            Router.events.emit("beforeHistoryChange", as, routeProps);
            _this.changeState(method, url, as, options);
            const canSkipUpdating = isQueryUpdating && !upcomingScrollState && !readyStateChange && !localeChange && (0, _compareStates).compareRouterStates(upcomingRouterState, _this.state);
            if (!canSkipUpdating) {
              try {
                yield _this.set(upcomingRouterState, routeInfo, upcomingScrollState);
              } catch (e) {
                if (e.cancelled)
                  routeInfo.error = routeInfo.error || e;
                else
                  throw e;
              }
              if (routeInfo.error) {
                if (!isQueryUpdating) {
                  Router.events.emit("routeChangeError", routeInfo.error, cleanedAs, routeProps);
                }
                throw routeInfo.error;
              }
              if (process.env.__NEXT_I18N_SUPPORT) {
                if (nextState.locale) {
                  document.documentElement.lang = nextState.locale;
                }
              }
              if (!isQueryUpdating) {
                Router.events.emit("routeChangeComplete", as, routeProps);
              }
              const hashRegex = /#.+$/;
              if (shouldScroll && hashRegex.test(as)) {
                _this.scrollToHash(as);
              }
            }
            return true;
          } catch (err1) {
            if ((0, _isError).default(err1) && err1.cancelled) {
              return false;
            }
            throw err1;
          }
        })();
      }
      changeState(method, url, as, options = {}) {
        if (true) {
          if (typeof window.history === "undefined") {
            console.error(`Warning: window.history is not available.`);
            return;
          }
          if (typeof window.history[method] === "undefined") {
            console.error(`Warning: window.history.${method} is not available`);
            return;
          }
        }
        if (method !== "pushState" || (0, _utils).getURL() !== as) {
          this._shallow = options.shallow;
          window.history[method](
            {
              url,
              as,
              options,
              __N: true,
              key: this._key = method !== "pushState" ? this._key : createKey()
            },
            // Most browsers currently ignores this parameter, although they may use it in the future.
            // Passing the empty string here should be safe against future changes to the method.
            // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState
            "",
            as
          );
        }
      }
      handleRouteInfoError(err, pathname, query, as, routeProps, loadErrorFail) {
        var _this = this;
        return _async_to_generator(function* () {
          console.error(err);
          if (err.cancelled) {
            throw err;
          }
          if ((0, _routeLoader).isAssetError(err) || loadErrorFail) {
            Router.events.emit("routeChangeError", err, as, routeProps);
            handleHardNavigation({
              url: as,
              router: _this
            });
            throw buildCancellationError();
          }
          try {
            let props;
            const { page: Component, styleSheets } = yield _this.fetchComponent("/_error");
            const routeInfo = {
              props,
              Component,
              styleSheets,
              err,
              error: err
            };
            if (!routeInfo.props) {
              try {
                routeInfo.props = yield _this.getInitialProps(Component, {
                  err,
                  pathname,
                  query
                });
              } catch (gipErr) {
                console.error("Error in error page `getInitialProps`: ", gipErr);
                routeInfo.props = {};
              }
            }
            return routeInfo;
          } catch (routeInfoErr) {
            return _this.handleRouteInfoError((0, _isError).default(routeInfoErr) ? routeInfoErr : new Error(routeInfoErr + ""), pathname, query, as, routeProps, true);
          }
        })();
      }
      getRouteInfo({ route: requestedRoute, pathname, query, as, resolvedAs, routeProps, locale, hasMiddleware, isPreview, unstable_skipClientCache, isQueryUpdating, isMiddlewareRewrite, isNotFound }) {
        var _this = this;
        return _async_to_generator(function* () {
          let route = requestedRoute;
          try {
            var ref, ref11, ref12, ref13;
            const handleCancelled = getCancelledHandler({
              route,
              router: _this
            });
            let existingInfo = _this.components[route];
            if (routeProps.shallow && existingInfo && _this.route === route) {
              return existingInfo;
            }
            if (hasMiddleware) {
              existingInfo = void 0;
            }
            let cachedRouteInfo = existingInfo && !("initial" in existingInfo) && false ? existingInfo : void 0;
            const isBackground = isQueryUpdating;
            const fetchNextDataParams = {
              dataHref: _this.pageLoader.getDataHref({
                href: (0, _formatUrl).formatWithValidation({
                  pathname,
                  query
                }),
                skipInterpolation: true,
                asPath: isNotFound ? "/404" : resolvedAs,
                locale
              }),
              hasMiddleware: true,
              isServerRender: _this.isSsr,
              parseJSON: true,
              inflightCache: isBackground ? _this.sbc : _this.sdc,
              persistCache: !isPreview,
              isPrefetch: false,
              unstable_skipClientCache,
              isBackground
            };
            let data = isQueryUpdating && !isMiddlewareRewrite ? null : yield withMiddlewareEffects({
              fetchData: () => fetchNextData(fetchNextDataParams),
              asPath: isNotFound ? "/404" : resolvedAs,
              locale,
              router: _this
            }).catch((err) => {
              if (isQueryUpdating) {
                return null;
              }
              throw err;
            });
            if (data && (pathname === "/_error" || pathname === "/404")) {
              data.effect = void 0;
            }
            if (isQueryUpdating) {
              if (!data) {
                data = {
                  json: self.__NEXT_DATA__.props
                };
              } else {
                data.json = self.__NEXT_DATA__.props;
              }
            }
            handleCancelled();
            if ((data == null ? void 0 : (ref = data.effect) == null ? void 0 : ref.type) === "redirect-internal" || (data == null ? void 0 : (ref11 = data.effect) == null ? void 0 : ref11.type) === "redirect-external") {
              return data.effect;
            }
            if ((data == null ? void 0 : (ref12 = data.effect) == null ? void 0 : ref12.type) === "rewrite") {
              const resolvedRoute = (0, _removeTrailingSlash).removeTrailingSlash(data.effect.resolvedHref);
              const pages = yield _this.pageLoader.getPageList();
              if (!isQueryUpdating || pages.includes(resolvedRoute)) {
                route = resolvedRoute;
                pathname = data.effect.resolvedHref;
                query = _extends({}, query, data.effect.parsedAs.query);
                resolvedAs = (0, _removeBasePath).removeBasePath((0, _normalizeLocalePath).normalizeLocalePath(data.effect.parsedAs.pathname, _this.locales).pathname);
                existingInfo = _this.components[route];
                if (routeProps.shallow && existingInfo && _this.route === route && !hasMiddleware) {
                  return _extends({}, existingInfo, {
                    route
                  });
                }
              }
            }
            if ((0, _isApiRoute).isAPIRoute(route)) {
              handleHardNavigation({
                url: as,
                router: _this
              });
              return new Promise(() => {
              });
            }
            const routeInfo = cachedRouteInfo || (yield _this.fetchComponent(route).then((res) => ({
              Component: res.page,
              styleSheets: res.styleSheets,
              __N_SSG: res.mod.__N_SSG,
              __N_SSP: res.mod.__N_SSP
            })));
            if (true) {
              const { isValidElementType } = require_react_is();
              if (!isValidElementType(routeInfo.Component)) {
                throw new Error(`The default export is not a React Component in page: "${pathname}"`);
              }
            }
            const wasBailedPrefetch = data == null ? void 0 : (ref13 = data.response) == null ? void 0 : ref13.headers.get("x-middleware-skip");
            const shouldFetchData = routeInfo.__N_SSG || routeInfo.__N_SSP;
            if (wasBailedPrefetch && (data == null ? void 0 : data.dataHref)) {
              delete _this.sdc[data.dataHref];
            }
            const { props, cacheKey } = yield _this._getData(_async_to_generator(function* () {
              if (shouldFetchData) {
                if ((data == null ? void 0 : data.json) && !wasBailedPrefetch) {
                  return {
                    cacheKey: data.cacheKey,
                    props: data.json
                  };
                }
                const dataHref = (data == null ? void 0 : data.dataHref) ? data.dataHref : _this.pageLoader.getDataHref({
                  href: (0, _formatUrl).formatWithValidation({
                    pathname,
                    query
                  }),
                  asPath: resolvedAs,
                  locale
                });
                const fetched = yield fetchNextData({
                  dataHref,
                  isServerRender: _this.isSsr,
                  parseJSON: true,
                  inflightCache: wasBailedPrefetch ? {} : _this.sdc,
                  persistCache: !isPreview,
                  isPrefetch: false,
                  unstable_skipClientCache
                });
                return {
                  cacheKey: fetched.cacheKey,
                  props: fetched.json || {}
                };
              }
              return {
                headers: {},
                props: yield _this.getInitialProps(
                  routeInfo.Component,
                  // we provide AppTree later so this needs to be `any`
                  {
                    pathname,
                    query,
                    asPath: as,
                    locale,
                    locales: _this.locales,
                    defaultLocale: _this.defaultLocale
                  }
                )
              };
            }));
            if (routeInfo.__N_SSP && fetchNextDataParams.dataHref && cacheKey) {
              delete _this.sdc[cacheKey];
            }
            if (!_this.isPreview && routeInfo.__N_SSG && false) {
              fetchNextData(Object.assign({}, fetchNextDataParams, {
                isBackground: true,
                persistCache: false,
                inflightCache: _this.sbc
              })).catch(() => {
              });
            }
            props.pageProps = Object.assign({}, props.pageProps);
            routeInfo.props = props;
            routeInfo.route = route;
            routeInfo.query = query;
            routeInfo.resolvedAs = resolvedAs;
            _this.components[route] = routeInfo;
            return routeInfo;
          } catch (err) {
            return _this.handleRouteInfoError((0, _isError).getProperError(err), pathname, query, as, routeProps);
          }
        })();
      }
      set(state, data, resetScroll) {
        this.state = state;
        return this.sub(data, this.components["/_app"].Component, resetScroll);
      }
      /**
      * Callback to execute before replacing router state
      * @param cb callback to be executed
      */
      beforePopState(cb) {
        this._bps = cb;
      }
      onlyAHashChange(as) {
        if (!this.asPath)
          return false;
        const [oldUrlNoHash, oldHash] = this.asPath.split("#");
        const [newUrlNoHash, newHash] = as.split("#");
        if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {
          return true;
        }
        if (oldUrlNoHash !== newUrlNoHash) {
          return false;
        }
        return oldHash !== newHash;
      }
      scrollToHash(as) {
        const [, hash = ""] = as.split("#");
        if (hash === "" || hash === "top") {
          (0, _handleSmoothScroll).handleSmoothScroll(() => window.scrollTo(0, 0));
          return;
        }
        const rawHash = decodeURIComponent(hash);
        const idEl = document.getElementById(rawHash);
        if (idEl) {
          (0, _handleSmoothScroll).handleSmoothScroll(() => idEl.scrollIntoView());
          return;
        }
        const nameEl = document.getElementsByName(rawHash)[0];
        if (nameEl) {
          (0, _handleSmoothScroll).handleSmoothScroll(() => nameEl.scrollIntoView());
        }
      }
      urlIsNew(asPath) {
        return this.asPath !== asPath;
      }
      /**
      * Prefetch page code, you may wait for the data during page rendering.
      * This feature only works in production!
      * @param url the href of prefetched page
      * @param asPath the as path of the prefetched page
      */
      prefetch(url, asPath = url, options = {}) {
        var _this = this;
        return _async_to_generator(function* () {
          if (true) {
            return;
          }
          if (typeof window !== "undefined" && (0, _isBot).isBot(window.navigator.userAgent)) {
            return;
          }
          let parsed = (0, _parseRelativeUrl).parseRelativeUrl(url);
          const urlPathname = parsed.pathname;
          let { pathname, query } = parsed;
          const originalPathname = pathname;
          if (process.env.__NEXT_I18N_SUPPORT) {
            if (options.locale === false) {
              pathname = (0, _normalizeLocalePath).normalizeLocalePath(pathname, _this.locales).pathname;
              parsed.pathname = pathname;
              url = (0, _formatUrl).formatWithValidation(parsed);
              let parsedAs = (0, _parseRelativeUrl).parseRelativeUrl(asPath);
              const localePathResult = (0, _normalizeLocalePath).normalizeLocalePath(parsedAs.pathname, _this.locales);
              parsedAs.pathname = localePathResult.pathname;
              options.locale = localePathResult.detectedLocale || _this.defaultLocale;
              asPath = (0, _formatUrl).formatWithValidation(parsedAs);
            }
          }
          const pages = yield _this.pageLoader.getPageList();
          let resolvedAs = asPath;
          const locale = typeof options.locale !== "undefined" ? options.locale || void 0 : _this.locale;
          const isMiddlewareMatch = yield matchesMiddleware({
            asPath,
            locale,
            router: _this
          });
          if (process.env.__NEXT_HAS_REWRITES && asPath.startsWith("/")) {
            let rewrites;
            ({ __rewrites: rewrites } = yield (0, _routeLoader).getClientBuildManifest());
            const rewritesResult = (0, _resolveRewrites).default((0, _addBasePath).addBasePath((0, _addLocale).addLocale(asPath, _this.locale), true), pages, rewrites, parsed.query, (p) => resolveDynamicRoute(p, pages), _this.locales);
            if (rewritesResult.externalDest) {
              return;
            }
            if (!isMiddlewareMatch) {
              resolvedAs = (0, _removeLocale).removeLocale((0, _removeBasePath).removeBasePath(rewritesResult.asPath), _this.locale);
            }
            if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {
              pathname = rewritesResult.resolvedHref;
              parsed.pathname = pathname;
              if (!isMiddlewareMatch) {
                url = (0, _formatUrl).formatWithValidation(parsed);
              }
            }
          }
          parsed.pathname = resolveDynamicRoute(parsed.pathname, pages);
          if ((0, _isDynamic).isDynamicRoute(parsed.pathname)) {
            pathname = parsed.pathname;
            parsed.pathname = pathname;
            Object.assign(query, (0, _routeMatcher).getRouteMatcher((0, _routeRegex).getRouteRegex(parsed.pathname))((0, _parsePath).parsePath(asPath).pathname) || {});
            if (!isMiddlewareMatch) {
              url = (0, _formatUrl).formatWithValidation(parsed);
            }
          }
          const data = process.env.__NEXT_MIDDLEWARE_PREFETCH === "strict" ? null : yield withMiddlewareEffects({
            fetchData: () => fetchNextData({
              dataHref: _this.pageLoader.getDataHref({
                href: (0, _formatUrl).formatWithValidation({
                  pathname: originalPathname,
                  query
                }),
                skipInterpolation: true,
                asPath: resolvedAs,
                locale
              }),
              hasMiddleware: true,
              isServerRender: _this.isSsr,
              parseJSON: true,
              inflightCache: _this.sdc,
              persistCache: !_this.isPreview,
              isPrefetch: true
            }),
            asPath,
            locale,
            router: _this
          });
          if ((data == null ? void 0 : data.effect.type) === "rewrite") {
            parsed.pathname = data.effect.resolvedHref;
            pathname = data.effect.resolvedHref;
            query = _extends({}, query, data.effect.parsedAs.query);
            resolvedAs = data.effect.parsedAs.pathname;
            url = (0, _formatUrl).formatWithValidation(parsed);
          }
          if ((data == null ? void 0 : data.effect.type) === "redirect-external") {
            return;
          }
          const route = (0, _removeTrailingSlash).removeTrailingSlash(pathname);
          if (yield _this._bfl(asPath, resolvedAs, options.locale, true)) {
            _this.components[urlPathname] = {
              __appRouter: true
            };
          }
          yield Promise.all([
            _this.pageLoader._isSsg(route).then((isSsg) => {
              return isSsg ? fetchNextData({
                dataHref: (data == null ? void 0 : data.json) ? data == null ? void 0 : data.dataHref : _this.pageLoader.getDataHref({
                  href: url,
                  asPath: resolvedAs,
                  locale
                }),
                isServerRender: false,
                parseJSON: true,
                inflightCache: _this.sdc,
                persistCache: !_this.isPreview,
                isPrefetch: true,
                unstable_skipClientCache: options.unstable_skipClientCache || options.priority && !!process.env.__NEXT_OPTIMISTIC_CLIENT_CACHE
              }).then(() => false).catch(() => false) : false;
            }),
            _this.pageLoader[options.priority ? "loadPage" : "prefetch"](route)
          ]);
        })();
      }
      fetchComponent(route) {
        var _this = this;
        return _async_to_generator(function* () {
          const handleCancelled = getCancelledHandler({
            route,
            router: _this
          });
          try {
            const componentResult = yield _this.pageLoader.loadPage(route);
            handleCancelled();
            return componentResult;
          } catch (err) {
            handleCancelled();
            throw err;
          }
        })();
      }
      _getData(fn) {
        let cancelled = false;
        const cancel = () => {
          cancelled = true;
        };
        this.clc = cancel;
        return fn().then((data) => {
          if (cancel === this.clc) {
            this.clc = null;
          }
          if (cancelled) {
            const err = new Error("Loading initial props cancelled");
            err.cancelled = true;
            throw err;
          }
          return data;
        });
      }
      _getFlightData(dataHref) {
        return fetchNextData({
          dataHref,
          isServerRender: true,
          parseJSON: false,
          inflightCache: this.sdc,
          persistCache: false,
          isPrefetch: false
        }).then(({ text }) => ({
          data: text
        }));
      }
      getInitialProps(Component, ctx) {
        const { Component: App } = this.components["/_app"];
        const AppTree = this._wrapApp(App);
        ctx.AppTree = AppTree;
        return (0, _utils).loadGetInitialProps(App, {
          AppTree,
          Component,
          router: this,
          ctx
        });
      }
      get route() {
        return this.state.route;
      }
      get pathname() {
        return this.state.pathname;
      }
      get query() {
        return this.state.query;
      }
      get asPath() {
        return this.state.asPath;
      }
      get locale() {
        return this.state.locale;
      }
      get isFallback() {
        return this.state.isFallback;
      }
      get isPreview() {
        return this.state.isPreview;
      }
      constructor(pathname1, query1, as1, { initialProps, pageLoader, App, wrapApp, Component, err, subscription, isFallback, locale, locales, defaultLocale, domainLocales, isPreview }) {
        this.sdc = {};
        this.sbc = {};
        this.isFirstPopStateEvent = true;
        this._key = createKey();
        this.onPopState = (e) => {
          const { isFirstPopStateEvent } = this;
          this.isFirstPopStateEvent = false;
          const state = e.state;
          if (!state) {
            const { pathname: pathname2, query } = this;
            this.changeState("replaceState", (0, _formatUrl).formatWithValidation({
              pathname: (0, _addBasePath).addBasePath(pathname2),
              query
            }), (0, _utils).getURL());
            return;
          }
          if (state.__NA) {
            window.location.reload();
            return;
          }
          if (!state.__N) {
            return;
          }
          if (isFirstPopStateEvent && this.locale === state.options.locale && state.as === this.asPath) {
            return;
          }
          let forcedScroll;
          const { url, as, options, key } = state;
          if (process.env.__NEXT_SCROLL_RESTORATION) {
            if (manualScrollRestoration) {
              if (this._key !== key) {
                try {
                  sessionStorage.setItem("__next_scroll_" + this._key, JSON.stringify({
                    x: self.pageXOffset,
                    y: self.pageYOffset
                  }));
                } catch (e2) {
                }
                try {
                  const v = sessionStorage.getItem("__next_scroll_" + key);
                  forcedScroll = JSON.parse(v);
                } catch (e1) {
                  forcedScroll = {
                    x: 0,
                    y: 0
                  };
                }
              }
            }
          }
          this._key = key;
          const { pathname } = (0, _parseRelativeUrl).parseRelativeUrl(url);
          if (this.isSsr && as === (0, _addBasePath).addBasePath(this.asPath) && pathname === (0, _addBasePath).addBasePath(this.pathname)) {
            return;
          }
          if (this._bps && !this._bps(state)) {
            return;
          }
          this.change("replaceState", url, as, Object.assign({}, options, {
            shallow: options.shallow && this._shallow,
            locale: options.locale || this.defaultLocale,
            // @ts-ignore internal value not exposed on types
            _h: 0
          }), forcedScroll);
        };
        const route = (0, _removeTrailingSlash).removeTrailingSlash(pathname1);
        this.components = {};
        if (pathname1 !== "/_error") {
          this.components[route] = {
            Component,
            initial: true,
            props: initialProps,
            err,
            __N_SSG: initialProps && initialProps.__N_SSG,
            __N_SSP: initialProps && initialProps.__N_SSP
          };
        }
        this.components["/_app"] = {
          Component: App,
          styleSheets: []
        };
        if (process.env.__NEXT_CLIENT_ROUTER_FILTER_ENABLED) {
          const { BloomFilter } = require_bloom_filter();
          const staticFilterData = process.env.__NEXT_CLIENT_ROUTER_S_FILTER;
          const dynamicFilterData = process.env.__NEXT_CLIENT_ROUTER_D_FILTER;
          if (staticFilterData == null ? void 0 : staticFilterData.hashes) {
            this._bfl_s = new BloomFilter(staticFilterData.size, staticFilterData.hashes);
            this._bfl_s.import(staticFilterData);
          }
          if (dynamicFilterData == null ? void 0 : dynamicFilterData.hashes) {
            this._bfl_d = new BloomFilter(dynamicFilterData.size, dynamicFilterData.hashes);
            this._bfl_d.import(dynamicFilterData);
          }
        }
        this.events = Router.events;
        this.pageLoader = pageLoader;
        const autoExportDynamic = (0, _isDynamic).isDynamicRoute(pathname1) && self.__NEXT_DATA__.autoExport;
        this.basePath = process.env.__NEXT_ROUTER_BASEPATH || "";
        this.sub = subscription;
        this.clc = null;
        this._wrapApp = wrapApp;
        this.isSsr = true;
        this.isLocaleDomain = false;
        this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || self.__NEXT_DATA__.appGip && !self.__NEXT_DATA__.gsp || !autoExportDynamic && !self.location.search && !process.env.__NEXT_HAS_REWRITES);
        if (process.env.__NEXT_I18N_SUPPORT) {
          this.locales = locales;
          this.defaultLocale = defaultLocale;
          this.domainLocales = domainLocales;
          this.isLocaleDomain = !!(0, _detectDomainLocale).detectDomainLocale(domainLocales, self.location.hostname);
        }
        this.state = {
          route,
          pathname: pathname1,
          query: query1,
          asPath: autoExportDynamic ? pathname1 : as1,
          isPreview: !!isPreview,
          locale: process.env.__NEXT_I18N_SUPPORT ? locale : void 0,
          isFallback
        };
        this._initialMatchesMiddlewarePromise = Promise.resolve(false);
        if (typeof window !== "undefined") {
          if (!as1.startsWith("//")) {
            const options = {
              locale
            };
            const asPath = (0, _utils).getURL();
            this._initialMatchesMiddlewarePromise = matchesMiddleware({
              router: this,
              locale,
              asPath
            }).then((matches) => {
              options._shouldResolveHref = as1 !== pathname1;
              this.changeState("replaceState", matches ? asPath : (0, _formatUrl).formatWithValidation({
                pathname: (0, _addBasePath).addBasePath(pathname1),
                query: query1
              }), asPath, options);
              return matches;
            });
          }
          window.addEventListener("popstate", this.onPopState);
          if (process.env.__NEXT_SCROLL_RESTORATION) {
            if (manualScrollRestoration) {
              window.history.scrollRestoration = "manual";
            }
          }
        }
      }
    };
    Router.events = (0, _mitt).default();
    exports.default = Router;
  }
});

// ../../../../../../node_modules/next/dist/shared/lib/router-context.js
var require_router_context = __commonJS({
  "../../../../../../node_modules/next/dist/shared/lib/router-context.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.RouterContext = void 0;
    var _interop_require_default = require_interop_require_default().default;
    var _react = _interop_require_default(require_react());
    var RouterContext = _react.default.createContext(null);
    exports.RouterContext = RouterContext;
    if (true) {
      RouterContext.displayName = "RouterContext";
    }
  }
});

// ../../../../../../node_modules/next/dist/client/with-router.js
var require_with_router = __commonJS({
  "../../../../../../node_modules/next/dist/client/with-router.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = withRouter;
    var _interop_require_default = require_interop_require_default().default;
    var _react = _interop_require_default(require_react());
    var _router = require_router2();
    function withRouter(ComposedComponent) {
      function WithRouterWrapper(props) {
        return _react.default.createElement(ComposedComponent, Object.assign({
          router: (0, _router).useRouter()
        }, props));
      }
      WithRouterWrapper.getInitialProps = ComposedComponent.getInitialProps;
      WithRouterWrapper.origGetInitialProps = ComposedComponent.origGetInitialProps;
      if (true) {
        const name = ComposedComponent.displayName || ComposedComponent.name || "Unknown";
        WithRouterWrapper.displayName = `withRouter(${name})`;
      }
      return WithRouterWrapper;
    }
    if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
      Object.defineProperty(exports.default, "__esModule", { value: true });
      Object.assign(exports.default, exports);
      module.exports = exports.default;
    }
  }
});

// ../../../../../../node_modules/next/dist/client/router.js
var require_router2 = __commonJS({
  "../../../../../../node_modules/next/dist/client/router.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "Router", {
      enumerable: true,
      get: function() {
        return _router.default;
      }
    });
    Object.defineProperty(exports, "withRouter", {
      enumerable: true,
      get: function() {
        return _withRouter.default;
      }
    });
    exports.useRouter = useRouter;
    exports.createRouter = createRouter;
    exports.makePublicRouterInstance = makePublicRouterInstance;
    exports.default = void 0;
    var _interop_require_default = require_interop_require_default().default;
    var _react = _interop_require_default(require_react());
    var _router = _interop_require_default(require_router());
    var _routerContext = require_router_context();
    var _isError = _interop_require_default(require_is_error());
    var _withRouter = _interop_require_default(require_with_router());
    var singletonRouter = {
      router: null,
      readyCallbacks: [],
      ready(cb) {
        if (this.router)
          return cb();
        if (typeof window !== "undefined") {
          this.readyCallbacks.push(cb);
        }
      }
    };
    var urlPropertyFields = [
      "pathname",
      "route",
      "query",
      "asPath",
      "components",
      "isFallback",
      "basePath",
      "locale",
      "locales",
      "defaultLocale",
      "isReady",
      "isPreview",
      "isLocaleDomain",
      "domainLocales"
    ];
    var routerEvents = [
      "routeChangeStart",
      "beforeHistoryChange",
      "routeChangeComplete",
      "routeChangeError",
      "hashChangeStart",
      "hashChangeComplete"
    ];
    var coreMethodFields = [
      "push",
      "replace",
      "reload",
      "back",
      "prefetch",
      "beforePopState"
    ];
    Object.defineProperty(singletonRouter, "events", {
      get() {
        return _router.default.events;
      }
    });
    function getRouter() {
      if (!singletonRouter.router) {
        const message = 'No router instance found.\nYou should only use "next/router" on the client side of your app.\n';
        throw new Error(message);
      }
      return singletonRouter.router;
    }
    urlPropertyFields.forEach((field) => {
      Object.defineProperty(singletonRouter, field, {
        get() {
          const router = getRouter();
          return router[field];
        }
      });
    });
    coreMethodFields.forEach((field) => {
      singletonRouter[field] = (...args) => {
        const router = getRouter();
        return router[field](...args);
      };
    });
    routerEvents.forEach((event) => {
      singletonRouter.ready(() => {
        _router.default.events.on(event, (...args) => {
          const eventField = `on${event.charAt(0).toUpperCase()}${event.substring(1)}`;
          const _singletonRouter = singletonRouter;
          if (_singletonRouter[eventField]) {
            try {
              _singletonRouter[eventField](...args);
            } catch (err) {
              console.error(`Error when running the Router event: ${eventField}`);
              console.error((0, _isError).default(err) ? `${err.message}
${err.stack}` : err + "");
            }
          }
        });
      });
    });
    var _default = singletonRouter;
    exports.default = _default;
    function useRouter() {
      const router = _react.default.useContext(_routerContext.RouterContext);
      if (!router) {
        throw new Error("NextRouter was not mounted. https://nextjs.org/docs/messages/next-router-not-mounted");
      }
      return router;
    }
    function createRouter(...args) {
      singletonRouter.router = new _router.default(...args);
      singletonRouter.readyCallbacks.forEach((cb) => cb());
      singletonRouter.readyCallbacks = [];
      return singletonRouter.router;
    }
    function makePublicRouterInstance(router) {
      const scopedRouter = router;
      const instance = {};
      for (const property of urlPropertyFields) {
        if (typeof scopedRouter[property] === "object") {
          instance[property] = Object.assign(Array.isArray(scopedRouter[property]) ? [] : {}, scopedRouter[property]);
          continue;
        }
        instance[property] = scopedRouter[property];
      }
      instance.events = _router.default.events;
      coreMethodFields.forEach((field) => {
        instance[field] = (...args) => {
          return scopedRouter[field](...args);
        };
      });
      return instance;
    }
    if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
      Object.defineProperty(exports.default, "__esModule", { value: true });
      Object.assign(exports.default, exports);
      module.exports = exports.default;
    }
  }
});

// ../../../../../../node_modules/next/router.js
var require_router3 = __commonJS({
  "../../../../../../node_modules/next/router.js"(exports, module) {
    module.exports = require_router2();
  }
});
export default require_router3();
/*! Bundled license information:

next/dist/compiled/react-is/cjs/react-is.development.js:
  (**
   * @license React
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=next_router.js.map
